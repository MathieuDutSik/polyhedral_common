\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\geometry{margin=1in}

\lstset{
    basicstyle=\ttfamily\small,
    breaklines=true,
    frame=single,
    language=C++,
    commentstyle=\color{gray},
    keywordstyle=\color{blue},
    stringstyle=\color{red}
}

\title{Polyhedral Common Library\\
\large Computational Tools for Polytopes, Lattices, and Quadratic Forms\\
Documentation}
\author{Mathieu Dutour Sikiric}
\date{\today}

\begin{document}

\maketitle

\tableofcontents
\newpage

\section{Introduction}

The Polyhedral Common Library is a comprehensive set of computational tools designed for advanced mathematical computations involving polytopes, quadratic forms, and lattices. The library is optimized for extreme performance to tackle record-breaking problems in computational mathematics.

\subsection{Key Features}

\begin{itemize}
    \item High-performance algorithms for polyhedral computations
    \item Extensive group theory functionality for polytope symmetries
    \item Lattice theory implementations (Delaunay domains, canonicalization)
    \item Copositivity and strict copositivity testing
    \item Short vector computations and enumeration
    \item Perfect form computations
    \item Indefinite and Lorentzian form reductions
    \item Support for multiple arithmetic types (exact rational, algebraic numbers, safe integers)
\end{itemize}

\subsection{Design Philosophy}

The library follows these core principles:
\begin{itemize}
    \item \textbf{Performance-First}: All algorithms are optimized for speed using group theory and polyhedral structures
    \item \textbf{Modularity}: Independent subdirectories for different functionalities
    \item \textbf{Flexibility}: Template-based design supporting multiple arithmetic types
    \item \textbf{Exactness}: Preference for exact arithmetic to avoid numerical errors
\end{itemize}

\section{Project Organization}

The project is organized into several independent subdirectories, each focusing on a specific mathematical domain:

\begin{description}
    \item[\texttt{src\_group}] Group theory computations for polytopes
    \item[\texttt{src\_poly}] Polyhedral computations (dual descriptions, facets, vertices)
    \item[\texttt{src\_latt}] Lattice computations (Delaunay, canonicalization, isomorphism)
    \item[\texttt{src\_dualdesc}] Dual description algorithms for serial computers
    \item[\texttt{src\_copos}] Copositivity and complete positivity testing
    \item[\texttt{src\_short}] Short vector enumeration and computations
    \item[\texttt{src\_perfect}] Perfect form computations
    \item[\texttt{src\_ctype}] C-type enumeration and classification
    \item[\texttt{src\_indefinite}] Indefinite quadratic form reduction
    \item[\texttt{src\_lorentzian}] Lorentzian/hyperbolic form algorithms (Vinberg, Edgewalk)
    \item[\texttt{src\_isotropy}] Isotropic vector finding and reduction
    \item[\texttt{src\_poincare\_polyhedron}] Poincaré polyhedron computations
    \item[\texttt{src\_sparse\_solver}] Sparse linear system solvers
\end{description}

\section{Module Documentation}

\subsection{Group Theory Module (\texttt{src\_group})}

This module provides comprehensive functionality for computing and manipulating groups acting on polytopes and lattices.

\subsubsection{Core Functionalities}

\paragraph{Matrix Group Operations}
The module implements efficient representations and operations on matrix groups, with algorithms for computing symmetry groups based on \cite{Bremner2014}:

\begin{itemize}
    \item \textbf{Group generation}: Constructing groups from generators
    \item \textbf{Orbit enumeration}: Computing orbits under group actions
    \item \textbf{Stabilizer computation}: Finding stabilizer subgroups
    \item \textbf{Double coset enumeration}: Computing double coset decompositions
    \item \textbf{Group simplification}: Reducing group representations
    \item \textbf{Linear, projective, and combinatorial symmetries}: Computation methods from \cite{Bremner2014}
\end{itemize}

\paragraph{Key Functions}

\begin{lstlisting}
// Write matrix group to file
template <typename T>
void write_matrix_group(
    std::vector<MyMatrix<T>> const &list_mat,
    std::string const &context);

// Compute rational invariant of matrix group
template <typename T>
size_t GetRationalInvariant(
    std::vector<MyMatrix<T>> const &ListGen);

// LLL reduction for matrix groups
template <typename T, typename Tint, typename Thelper>
std::pair<std::vector<MyMatrix<T>>, MyMatrix<Tint>>
LLLMatrixGroupReduction(
    Thelper const &helper,
    std::vector<MyMatrix<T>> const &ListMatr,
    std::ostream &os);

// Compute L1 norm of matrix group
template <typename T, typename Thelper>
T L1normMatrixGroup(
    Thelper const &helper,
    std::vector<MyMatrix<T>> const &ListMatr);
\end{lstlisting}

\subsubsection{Weighted Matrix Framework}

The weighted matrix framework is the foundation for computing equivalences, canonical orderings, and automorphism groups. A weighted matrix encodes the structure of a mathematical object (polytope, graph, etc.) as a matrix of discrete weights, enabling efficient graph-theoretic algorithms.

\paragraph{WeightMatrix Data Structure}

The \texttt{WeightMatrix} class is a template parameterized by:
\begin{itemize}
    \item \texttt{is\_symmetric}: Boolean indicating if the matrix is symmetric
    \item \texttt{T}: Type of the weights (can be numeric or vector types)
    \item \texttt{Tidx\_value}: Index type for weight storage (uint8\_t, uint16\_t, etc.)
\end{itemize}

\textbf{Construction}: A \texttt{WeightMatrix} is constructed from a function \texttt{f(i,j)} that computes the weight at position $(i,j)$. The constructor automatically:
\begin{enumerate}
    \item Enumerates all unique weight values
    \item Creates a compact index representation
    \item Stores weights in a compressed format
\end{enumerate}

\begin{lstlisting}
template <bool is_symmetric, typename T, typename Tidx_value>
struct WeightMatrix {
    // Constructor from function
    template <typename F>
    WeightMatrix(size_t const &nbRow, F f, std::ostream &os);

    // Get value at position (i,j)
    T GetValue(size_t iRow, size_t iCol) const;

    // Get number of rows
    size_t rows() const;

    // Get number of unique weights
    size_t GetWeightSize() const;
private:
    size_t nbRow;
    std::vector<T> ListWeight;          // Unique weights
    std::vector<Tidx_value> TheMat;     // Index matrix
    bool weight_ordered;
    std::ostream &os;
};
\end{lstlisting}

\paragraph{Core Functions for Weighted Matrices}

\begin{lstlisting}
// Compute stabilizer of a weighted matrix
template <typename T, typename Tgr, typename Tgroup,
          typename Tidx_value>
Tgroup GetStabilizerWeightMatrix(
    WeightMatrix<true, T, Tidx_value> const &WMat,
    std::ostream &os);

// Test equivalence between two weighted matrices
template <typename T, typename Telt, typename Tidx_value>
std::optional<Telt> TestEquivalenceWeightMatrix(
    WeightMatrix<true, T, Tidx_value> const &WMat1,
    WeightMatrix<true, T, Tidx_value> const &WMat2,
    std::ostream &os);

// Get canonical ordering of rows/columns
template <typename Tgr, typename Tidx>
std::vector<Tidx> GRAPH_GetCanonicalOrdering(
    Tgr const &eGR,
    std::ostream &os);
\end{lstlisting}

\subsubsection{Polytope Equivalence and Automorphism Groups}

\paragraph{Rational (Linear) Case}

For polytopes defined over fields (rationals, algebraic numbers), the module computes:

\begin{description}
    \item[Automorphism Group] The group of linear transformations preserving the polytope
    \item[Isomorphism] Whether two polytopes are linearly equivalent
    \item[Canonical Form] A unique representative for the isomorphism class. The canonical form algorithm is based on Dutour Sikirić et al. \cite{DutourSikiric2020}.
\end{description}

\textbf{Key Functions}:

\begin{lstlisting}
// Compute automorphism group of a polytope
template <typename T, typename Tgroup>
Tgroup LinPolytope_Automorphism(
    MyMatrix<T> const &EXT,
    std::ostream &os);

// With explicit Gram matrix (for optimization)
template <typename T, typename Tgroup>
Tgroup LinPolytope_Automorphism_GramMat(
    MyMatrix<T> const &EXT,
    MyMatrix<T> const &GramMat,
    std::ostream &os);

// Compute canonical ordering of vertices
template <typename T, typename Tidx>
std::vector<Tidx> LinPolytope_CanonicOrdering(
    MyMatrix<T> const &EXT,
    size_t threshold,
    std::ostream &os);

// With explicit Gram matrix
template <typename T, typename Tidx>
std::vector<Tidx> LinPolytope_CanonicOrdering_GramMat(
    MyMatrix<T> const &EXT,
    MyMatrix<T> const &GramMat,
    size_t threshold,
    std::ostream &os);
\end{lstlisting}

\paragraph{Integral Case}

For lattice polytopes (vertices with integer coordinates), we distinguish:
\begin{itemize}
    \item \textbf{Linear equivalence}: Equivalence under any invertible linear map
    \item \textbf{Integral equivalence}: Equivalence under unimodular (det=$\pm 1$) integer matrices
\end{itemize}

The integral automorphism group is a \emph{finite} subgroup of the linear automorphism group.

\textbf{Key Functions}:

\begin{lstlisting}
// Compute integral automorphism group
template <typename Tint, typename Tgroup>
Tgroup LinPolytopeIntegral_Automorphism(
    const MyMatrix<Tint> &EXT,
    std::ostream &os);

// Test integral isomorphism between polytopes
template <typename Tint, typename Tgroup>
std::optional<MyMatrix<Tint>>
LinPolytopeIntegral_Isomorphism(
    const MyMatrix<Tint> &EXT1,
    const MyMatrix<Tint> &EXT2,
    std::ostream &os);

// With explicit Gram matrices
template <typename T, typename Tint, typename Tgroup>
std::optional<MyMatrix<Tint>>
LinPolytopeIntegral_Isomorphism_GramMat(
    const MyMatrix<Tint> &EXT1,
    const MyMatrix<T> &GramMat1,
    const MyMatrix<Tint> &EXT2,
    const MyMatrix<T> &GramMat2,
    std::ostream &os);

// Automorphism with right coset representatives
template <typename Tint, typename Tgroup>
std::pair<Tgroup, std::vector<typename Tgroup::Telt>>
LinPolytopeIntegral_Automorphism_RightCoset(
    const MyMatrix<Tint> &EXT,
    std::ostream &os);
\end{lstlisting}

\paragraph{Algorithm Overview}

The computation proceeds in several steps:

\begin{enumerate}
    \item \textbf{Weight Matrix Construction}: From the polytope vertex matrix \texttt{EXT}, construct a weighted matrix encoding pairwise distances or inner products
    \item \textbf{Graph Automorphism}: Convert the weighted matrix to a colored graph and compute its automorphism group using nauty/Traces
    \item \textbf{Filtering}: For integral equivalence, filter the linear automorphisms to retain only unimodular transformations
    \item \textbf{Group Construction}: Build the group from generators
\end{enumerate}

For isomorphism testing:
\begin{enumerate}
    \item Compute canonical orderings of both polytopes
    \item Compare canonical forms; if different, polytopes are non-isomorphic
    \item If canonical forms match, construct and verify the isomorphism
    \item For integral isomorphism, verify the transformation is unimodular
\end{enumerate}

\paragraph{Subset Operations}

The module also supports operations on subsets (faces) of polytopes:

\begin{lstlisting}
// Test equivalence of two subsets
template <typename T, typename Telt, typename Tidx_value>
std::optional<Telt> TestEquivalenceSubset(
    WeightMatrix<true, T, Tidx_value> const &WMat,
    Face const &f1,
    Face const &f2,
    std::ostream &os);

// Compute stabilizer of a subset
template <typename T, typename Tgroup, typename Tidx_value>
Tgroup StabilizerSubset(
    WeightMatrix<true, T, Tidx_value> const &WMat,
    Face const &f,
    std::ostream &os);
\end{lstlisting}

\subsubsection{Performance Optimizations}

\begin{itemize}
    \item \textbf{Index type selection}: Automatically choose \texttt{uint8\_t}, \texttt{uint16\_t}, \texttt{uint32\_t}, or \texttt{uint64\_t} based on the number of unique weights
    \item \textbf{Symmetric exploitation}: For symmetric matrices, store only upper/lower triangle
    \item \textbf{Threshold schemes}: Use subset-based algorithms for large polytopes (threshold = 1000 by default)
    \item \textbf{Gram matrix caching}: Pre-compute and reuse Gram matrices for repeated queries
    \item \textbf{Centrally symmetric polytopes}: Exploit absolute value trick to reduce computation
\end{itemize}

\subsubsection{Key Header Files}

\begin{description}
    \item[\texttt{WeightMatrix.h}] Core weighted matrix data structure and algorithms
    \item[\texttt{WeightMatrixLimited.h}] Memory-limited variants for large matrices
    \item[\texttt{WeightMatrixSpecified.h}] Specialized weighted matrix constructions
    \item[\texttt{PolytopeEquiStab.h}] Polytope equivalence and stabilizer (rational case)
    \item[\texttt{PolytopeEquiStabInt.h}] Integral equivalence and automorphism groups
    \item[\texttt{MatrixGroupBasic.h}] Basic matrix group operations and utilities
    \item[\texttt{MatrixGroup.h}] Core matrix group data structures
    \item[\texttt{OrbitEnumeration.h}] Orbit computation algorithms
    \item[\texttt{GRP\_DoubleCoset.h}] Double coset enumeration
    \item[\texttt{MatrixGroupSimplification.h}] Group simplification algorithms
\end{description}

\subsection{Polyhedral Module (\texttt{src\_poly})}

This module handles all aspects of polyhedral computations, including dual descriptions, face enumeration, and linear programming.

\subsubsection{Core Functionalities}

\paragraph{Basic Operations}
\begin{itemize}
    \item \textbf{Row selection}: Extracting submatrices based on face specifications
    \item \textbf{Facet testing}: Verifying facet inequalities
    \item \textbf{Face enumeration}: Computing all faces of a polytope
    \item \textbf{Dual description}: Converting between vertex and facet representations
\end{itemize}

\paragraph{Key Functions}

\begin{lstlisting}
// Select rows from matrix based on face
template <typename T>
MyMatrix<T> SelectRow(
    MyMatrix<T> const &TheMat,
    Face const &eList);

// Select rows and drop a column
template <typename T>
MyMatrix<T> SelectRowDropColumnFace(
    MyMatrix<T> const &TheMat,
    Face const &eList,
    int const &idx_drop);

// Test if a face defines a valid facet
template <typename T>
bool TestFacetInequality(
    MyMatrix<T> const &EXT,
    Face const &eList);
\end{lstlisting}

\subsubsection{Algorithms}

\begin{description}
    \item[cddlib integration] Interface to cddlib for dual description
    \item[Direct dual description] Custom implementation for specific cases
    \item[Redundancy removal] Identifying and removing redundant constraints
    \item[Linear programming] Solving linear programs over polytopes
\end{description}

\subsection{Lattice Module (\texttt{src\_latt})}

The lattice module provides advanced algorithms for lattice computations, particularly focusing on positive definite quadratic forms.

\subsubsection{Core Functionalities}

\paragraph{Shortest Vectors}
The module implements efficient algorithms for computing shortest vectors in lattices:

\begin{lstlisting}
// Data structure for shortest vectors
template <typename T, typename Tint>
struct Tshortest {
    T min;                  // Minimum norm
    MyMatrix<Tint> SHV;     // Shortest vectors
};

// Select shortest vectors from a set
template <typename T, typename Tint>
Tshortest<T, Tint> SelectShortestVector(
    MyMatrix<T> const &eMat,
    MyMatrix<Tint> const &SHV);

// Apply transformation to shortest vectors
template <typename T, typename Tint>
Tshortest<T, Tint> apply_transformation(
    Tshortest<T, Tint> const &rec_shv,
    MyMatrix<Tint> const &P);

// Get half of the shortest vectors (exploit symmetry)
template <typename T, typename Tint>
Tshortest<T, Tint> shortest_get_half(
    Tshortest<T, Tint> const &rec_shv);
\end{lstlisting}

\paragraph{Delaunay Computations}
\begin{itemize}
    \item \textbf{Delaunay domain enumeration}: Computing Delaunay polytopes and Voronoi cells \cite{DutourSikiric2008a}
    \item \textbf{Isodelaunay domains}: Finding isomorphism classes using generalized Voronoi reduction \cite{DutourSikiric2007}
    \item \textbf{Fundamental domains}: Computing fundamental Delaunay domains
\end{itemize}

The algorithms for Voronoi cell computation are particularly effective for lattices up to dimension 12 and symmetric lattices, as established in \cite{DutourSikiric2008a}.

\paragraph{Canonicalization}
\begin{itemize}
    \item \textbf{Matrix canonicalization}: Computing canonical forms of positive definite matrices \cite{DutourSikiric2020}
    \item \textbf{Automorphism groups}: Finding symmetries of lattices
    \item \textbf{Isomorphism testing}: Determining lattice equivalence
    \item \textbf{Reduction with symmetry}: Voronoi reduction for forms with prescribed symmetries \cite{DutourSikiric2007}
\end{itemize}

\subsubsection{Key Header Files}

\begin{description}
    \item[\texttt{LatticeDefinitions.h}] Core data structures and basic operations
    \item[\texttt{LatticeDelaunay.h}] Delaunay domain computations
    \item[\texttt{LatticeStabEquiCan.h}] Stabilizer, equivalence, and canonicalization
    \item[\texttt{FundamentalDelaunay.h}] Fundamental Delaunay domains
\end{description}

\subsection{Dual Description Module (\texttt{src\_dualdesc})}

Specialized module for computing dual descriptions of polytopes on serial computers with optimizations for large-scale problems.

\subsubsection{Algorithms}
\begin{itemize}
    \item Serial dual description
    \item MPI-based parallel dual description \cite{Deza2015}
    \item Database-backed enumeration
    \item Balinski enumeration
    \item Perfect form enumeration methods \cite{DutourSikiric2007b}
\end{itemize}

\textbf{References}: The MPI parallelization strategies are based on methods from \cite{Deza2015}, and the enumeration techniques for perfect forms from \cite{DutourSikiric2007b}.

\subsection{Copositivity Module (\texttt{src\_copos})}

This module implements tests for copositivity and complete positivity of matrices based on the simplex algorithm for CP-factorization \cite{DutourSikiric2018}.

\subsubsection{Core Functionalities}
\begin{itemize}
    \item \textbf{Copositivity testing}: Determining if a matrix is copositive
    \item \textbf{Strict copositivity}: Testing for strict copositivity
    \item \textbf{Complete positivity}: Verifying complete positivity using the algorithm from \cite{DutourSikiric2018}
    \item \textbf{Copositive kernel}: Computing the kernel in copositive cone
    \item \textbf{CP-factorization}: Rational cp-factorization for completely positive matrices
\end{itemize}

\subsection{Short Vector Module (\texttt{src\_short})}

Focuses on computing and enumerating short vectors in lattices.

\subsubsection{Main Programs}
\begin{description}
    \item[\texttt{SHORT\_GetShortestVector}] Finds shortest vectors in a lattice
    \item[\texttt{SHORT\_AutomorphismGroup}] Computes automorphism group from short vectors
    \item[\texttt{SHORT\_CheckPrimeRealizability}] Tests realizability over finite fields
    \item[\texttt{SHORT\_EnumerateCyclicCases}] Enumerates special cyclic cases
\end{description}

\subsection{Perfect Forms Module (\texttt{src\_perfect})}

Implements algorithms for perfect quadratic forms, which are critical points of the Hermite function. The classification methods are based on \cite{DutourSikiric2007b} and T-space analysis from \cite{Gangl2013}.

\subsubsection{Functionalities}
\begin{itemize}
    \item Perfect form enumeration using symmetry exploitation \cite{DutourSikiric2007b}
    \item Perfect cone computations
    \item T-space analysis and polyhedral reduction \cite{Gangl2013}
    \item MPI-based parallel enumeration
\end{itemize}

\subsection{Indefinite Forms Module (\texttt{src\_indefinite})}

Handles computations with indefinite quadratic forms.

\subsubsection{Core Operations}
\begin{itemize}
    \item Automorphism group computation
    \item Isotropic plane stabilizers
    \item Canonical form computation
    \item Equivalence testing
\end{itemize}

\subsection{Lorentzian Module (\texttt{src\_lorentzian})}

Implements algorithms specific to Lorentzian (hyperbolic) quadratic forms.

\subsubsection{Algorithms}
\begin{itemize}
    \item \textbf{Vinberg algorithm}: Computing fundamental domains for reflection groups
    \item \textbf{Edgewalk algorithm}: Alternative approach using edge enumeration, based on Allcock's faster alternative to Vinberg's algorithm \cite{Allcock2021}. This method can significantly outperform the classical Vinberg algorithm, especially for computationally demanding cases.
    \item \textbf{Allcock algorithm}: Specialized 2-dimensional anisotropic cases
    \item \textbf{Coxeter dynamics}: Analysis of Coxeter diagrams and symbols
\end{itemize}

\textbf{Reference}: For the edgewalk algorithm, see Allcock, D. (2021). \textit{An Alternative to Vinberg's Algorithm}. arXiv:2110.03784.

\subsection{Isotropy Module (\texttt{src\_isotropy})}

Focuses on finding isotropic vectors of quadratic forms and computing approximate reduction and canonical forms for indefinite quadratic forms.

\subsubsection{Functionalities}
\begin{itemize}
    \item Finding isotropic vectors of quadratic forms
    \item Indefinite LLL reduction (approximate reduction and canonical form)
    \item Diophantine approximation
    \item Determinant minimization
    \item Positivity testing and computation of signature
\end{itemize}

\section{Arithmetic Types}

The library supports multiple arithmetic types through templates, allowing users to choose the appropriate precision and performance trade-offs.

\subsection{Functional Types}

For exact computations over algebraic number fields:

\begin{description}
    \item[\texttt{Qsqrt2}] The field $\mathbb{Q}(\sqrt{2})$
    \item[\texttt{Qsqrt3}] The field $\mathbb{Q}(\sqrt{3})$
    \item[\texttt{Qsqrt5}] The field $\mathbb{Q}(\sqrt{5})$
    \item[\texttt{RealAlgebraic}] General real algebraic numbers (via continued fractions)
\end{description}

\textbf{Syntax}: Coefficients are written as: \texttt{1}, \texttt{1+x}, \texttt{x/4}, \texttt{-3-3x/4}, \texttt{3+(3*4)*x\^{}3}

\subsection{Speed Types}

For high-performance computations:

\begin{description}
    \item[\texttt{mpq\_class}] GMP rational numbers (recommended default)
    \item[\texttt{mpz\_class}] GMP arbitrary precision integers
    \item[\texttt{cpp\_rational}] Boost multiprecision rational (header-only)
    \item[\texttt{cpp\_int}] Boost multiprecision integer (header-only)
    \item[\texttt{SafeInt64}] Protected 64-bit integers with overflow detection
    \item[\texttt{Rational<SafeInt64>}] Safe rational arithmetic
\end{description}

\section{Compilation and Usage}

\subsection{Dependencies}

The following libraries are required:

\begin{itemize}
    \item \textbf{Eigen}: Linear algebra library (\url{http://eigen.tuxfamily.org/})
    \item \textbf{Boost}: C++ utility libraries (\url{http://www.boost.org/})
    \item \textbf{GMP}: GNU Multiple Precision Library (\url{https://gmplib.org/})
    \item \textbf{nauty}: Graph automorphism library (\url{https://pallini.di.uniroma1.it/})
\end{itemize}

\subsection{Accessing the Source Code}

The repository uses submodules. Clone with:

\begin{lstlisting}[language=bash]
git clone https://github.com/MathieuDutSik/polyhedral_common --recursive
\end{lstlisting}

Or if already cloned without \texttt{--recursive}:

\begin{lstlisting}[language=bash]
./init.sh
\end{lstlisting}

Update submodules:

\begin{lstlisting}[language=bash]
./update.sh
\end{lstlisting}

\subsection{Compilation Methods}

There are three ways to compile the code, listed from simplest to most flexible:

\subsubsection{Method 1: Docker (Recommended for Quick Start)}

This is the simplest method as all dependencies are handled automatically by Docker.

\begin{lstlisting}[language=bash]
# Build using Docker
./compile_docker.sh
\end{lstlisting}

The Dockerfile contains the complete build environment specification and can be found at \texttt{docker\_files/Dockerfile}. This method is ideal for:
\begin{itemize}
    \item First-time users
    \item Ensuring reproducible builds
    \item Avoiding manual dependency installation
\end{itemize}

\subsubsection{Method 2: CMake (Requires Eigen3)}

Use CMake for a system-wide build. This method requires Eigen3 to be installed on your system.

\textbf{Prerequisites:}
\begin{itemize}
    \item CMake $\geq$ 3.30
    \item Eigen3 $\geq$ 3.3
    \item Boost (with serialization component)
    \item GMP and GMPXX libraries
\end{itemize}

\textbf{Build commands:}

\begin{lstlisting}[language=bash]
# Using the provided script
./compile.sh

# Or manually
mkdir -p build
cd build
cmake ..
make -j$(nproc)
\end{lstlisting}

The \texttt{CMakeLists.txt} file automatically:
\begin{itemize}
    \item Finds required packages (Eigen3, Boost, GMP)
    \item Sets C++17 standard
    \item Configures include paths and link libraries
    \item Builds all modules
\end{itemize}

\subsubsection{Method 3: Individual Makefiles (Most Flexible)}

Each subdirectory (\texttt{src\_group}, \texttt{src\_poly}, \texttt{src\_latt}, etc.) contains its own Makefile for independent compilation.

This method allows:
\begin{itemize}
    \item Compiling only specific modules
    \item Custom compiler flags and optimizations
    \item Fine-grained control over the build process
\end{itemize}

\textbf{Example:}

\begin{lstlisting}[language=bash]
# Compile only the group module
cd src_group
make

# Compile a specific program
cd src_latt
make LATT_Automorphism

# Clean build artifacts
make clean
\end{lstlisting}

\textbf{Note:} When using individual Makefiles, ensure:
\begin{itemize}
    \item All dependencies are installed and accessible
    \item Include paths point to Eigen3, Boost, and other headers
    \item The \texttt{basic\_common\_cpp} submodule is initialized
\end{itemize}

\subsection{Compilation Options}

Regardless of the method chosen, you can enable various compilation options by setting environment variables or modifying the Makefile/CMakeLists.txt:

\begin{description}
    \item[\texttt{-DDEBUG}] Enable all debugging output
    \item[\texttt{-DTIMINGS}] Enable timing measurements
    \item[\texttt{-DSANITY\_CHECK}] Enable runtime sanity checks
    \item[\texttt{-O3}] Enable aggressive optimizations (recommended for production)
    \item[\texttt{-g}] Include debugging symbols
\end{description}

\subsection{Debug and Runtime Options}

Several environment variables control debugging and profiling:

\begin{description}
    \item[\texttt{DEBUG}] Enable debugging output and fast checks
    \item[\texttt{TIMINGS}] Print runtime information
    \item[\texttt{SANITY\_CHECK}] Perform consistency checks
    \item[\texttt{SANITY\_CHECK\_EXTENSIVE}] Perform expensive consistency checks
    \item[\texttt{KEY\_VALUE}] Print key-value pairs for optimization
    \item[\texttt{TRACK\_INFO}] Print tracking information
    \item[\texttt{METHOD\_COMPARISON}] Compare different method implementations
\end{description}

For granular control, use module-specific flags like \texttt{DEBUG\_LINEAR\_PROGRAM}.

\section{Testing}

\subsection{Test Organization}

\begin{description}
    \item[\texttt{CI\_tests/}] Continuous integration tests (5 min - 1 hour runtime)
    \item[\texttt{Exmpl\_Bench/}] Development and experimental tests
\end{description}

Tests are run via GitHub Actions with scheduled monthly execution to manage compute credits.

\section{Integration with Computer Algebra Systems}

The library can be interfaced with:

\begin{itemize}
    \item \textbf{GAP} (Group Algebra Programming)
    \item \textbf{Oscar} (Julia-based)
    \item \textbf{Sage} (Python-based)
\end{itemize}

Primary usage remains through CLI programs.

\section{Common Data Structures}

\subsection{Matrix Types}

\begin{lstlisting}
template <typename T>
class MyMatrix;  // Dense matrix

template <typename T>
class MyVector;  // Vector type
\end{lstlisting}

\subsection{Face Representation}

\begin{lstlisting}
using Face = boost::dynamic_bitset<>;  // Bitset for faces
\end{lstlisting}

Faces represent subsets of vertices or facets as bitsets for efficiency.

\subsection{Group Types}

Matrix groups are represented as vectors of generators:

\begin{lstlisting}
template <typename T>
using MatrixGroup = std::vector<MyMatrix<T>>;
\end{lstlisting}

\section{Performance Considerations}

\subsection{Group Exploitation}

A key optimization strategy is using group theory:
\begin{itemize}
    \item Orbit-based enumeration reduces redundant computation
    \item Canonical forms enable efficient isomorphism testing
    \item Stabilizer chains optimize group operations
\end{itemize}

\subsection{Memory Management}

The library uses:
\begin{itemize}
    \item Bitsets for compact face representation
    \item Move semantics for efficient memory transfer
    \item Template specialization for type-specific optimizations
\end{itemize}

\subsection{Parallelization}

Selected modules support MPI-based parallelization:
\begin{itemize}
    \item \texttt{LATT\_MPI\_ComputeDelaunay}
    \item \texttt{POLY\_MPI\_DualDesc}
    \item \texttt{PERF\_MPI\_EnumeratePerfectCones}
\end{itemize}

\section{Error Handling}

\subsection{Exception Types}

The library uses \texttt{TerminalException} for unrecoverable errors:

\begin{lstlisting}
throw TerminalException{1};
\end{lstlisting}

\subsection{Output Streams}

Functions accept \texttt{std::ostream\& os} parameters for flexible output:
\begin{itemize}
    \item Serial programs: pass \texttt{std::cerr}
    \item Parallel programs: pass process-specific streams
\end{itemize}

This prevents output mixing in parallel execution.

\section{Contributing and Development}

\subsection{Code Style}

\begin{itemize}
    \item Template-based generic programming
    \item Header-only when possible
    \item Clear separation of interface and implementation
    \item Extensive use of \texttt{const} correctness
    \item No trailing whitespace
\end{itemize}

\subsection{Adding New Functionality}

To add new functionality:

\begin{enumerate}
    \item Choose appropriate module or create new subdirectory
    \item Define template interfaces for arithmetic flexibility
    \item Add CI tests in \texttt{CI\_tests/}
    \item Document in header files
    \item Consider MPI parallelization for expensive operations
\end{enumerate}

\section{References and Further Reading}

\subsection{Repository}

\begin{itemize}
    \item GitHub: \url{https://github.com/MathieuDutSik/polyhedral_common}
    \item Issues and bug reports: GitHub issue tracker
\end{itemize}

\section{Appendix: Main Programs}

This appendix lists the main executable programs provided by each module. Each program can be compiled independently and provides specific functionality.

\subsection{Group Module (\texttt{src\_group})}

\begin{description}
    \item[\texttt{GRP\_LinPolytope\_Automorphism}] Compute automorphism group of a polytope
    \item[\texttt{GRP\_LinPolytope\_Isomorphism}] Test isomorphism between polytopes
    \item[\texttt{GRP\_LinPolytope\_Canonic}] Compute canonical form of a polytope
    \item[\texttt{GRP\_LinPolytopeIntegral\_Automorphism}] Compute integral automorphism group
    \item[\texttt{GRP\_LinPolytopeIntegral\_Isomorphism}] Test integral isomorphism
    \item[\texttt{GRP\_LinearSpace\_Stabilizer}] Compute stabilizer of a linear space
    \item[\texttt{GRP\_LinearSpace\_Equivalence}] Test equivalence of linear spaces
\end{description}

\subsection{Polyhedral Module (\texttt{src\_poly})}

\begin{description}
    \item[\texttt{POLY\_dual\_description}] Compute dual description (vertices $\leftrightarrow$ facets)
    \item[\texttt{POLY\_dual\_description\_group}] Dual description with group exploitation
    \item[\texttt{POLY\_redundancy}] Remove redundant inequalities
    \item[\texttt{POLY\_cdd\_LinearProgramming}] Solve linear programs over polytopes
    \item[\texttt{POLY\_FaceLatticeGen}] Generate face lattice of a polytope
    \item[\texttt{POLY\_IntegralPoints}] Enumerate integral points in a polytope
    \item[\texttt{POLY\_lrs}] Interface to lrs for vertex/facet enumeration
\end{description}

\subsection{Lattice Module (\texttt{src\_latt})}

\begin{description}
    \item[\texttt{LATT\_Automorphism}] Compute automorphism group of a lattice
    \item[\texttt{LATT\_Isomorphism}] Test isomorphism between lattices
    \item[\texttt{LATT\_Canonicalize}] Compute canonical form of a positive definite matrix
    \item[\texttt{LATT\_SerialComputeDelaunay}] Compute Delaunay polytopes (serial)
    \item[\texttt{LATT\_MPI\_ComputeDelaunay}] Compute Delaunay polytopes (MPI parallel)
    \item[\texttt{LATT\_SerialLattice\_IsoDelaunayDomain}] Enumerate IsoDelaunay domains (serial)
    \item[\texttt{LATT\_MPI\_Lattice\_IsoDelaunayDomain}] Enumerate IsoDelaunay domains (MPI)
    \item[\texttt{TSPACE\_Stabilizer}] Compute stabilizer of a T-space
    \item[\texttt{TSPACE\_Equivalence}] Test equivalence of T-spaces
\end{description}

\subsection{Dual Description Module (\texttt{src\_dualdesc})}

\begin{description}
    \item[\texttt{POLY\_SerialDualDesc}] Serial dual description with database
    \item[\texttt{POLY\_MPI\_DualDesc}] MPI-based parallel dual description
    \item[\texttt{POLY\_DirectSerialDualDesc}] Direct serial dual description
    \item[\texttt{POLY\_EvaluateDualDesc}] Evaluate dual description methods
    \item[\texttt{POLY\_RunTheBank}] Bank-based enumeration system
\end{description}

\subsection{Copositivity Module (\texttt{src\_copos})}

\begin{description}
    \item[\texttt{CP\_TestCopositivity}] Test if a matrix is copositive
    \item[\texttt{CP\_TestStrictCopositivity}] Test if a matrix is strictly copositive
    \item[\texttt{CP\_TestCompletePositivity}] Test if a matrix is completely positive
    \item[\texttt{CP\_CopositiveMin}] Find minimum over copositive cone
\end{description}

\subsection{Perfect Forms Module (\texttt{src\_perfect})}

\begin{description}
    \item[\texttt{PERF\_MPI\_EnumeratePerfectCones}] Enumerate perfect cones (MPI parallel)
    \item[\texttt{PERF\_SerialPerfectComputation}] Perfect form computations (serial)
\end{description}

\subsection{Lorentzian Module (\texttt{src\_lorentzian})}

\begin{description}
    \item[\texttt{LORENTZ\_FundDomain\_AllcockEdgewalk\_Isomorphism}] Edgewalk algorithm for fundamental domains
    \item[\texttt{LORENTZ\_ComputeStabilizer\_Vertex}] Compute stabilizer of a vertex
    \item[\texttt{COXDYN\_ComputeSymbol}] Compute Coxeter diagram symbol
    \item[\texttt{COXDYN\_FindExtensions}] Find extensions of Coxeter diagrams
\end{description}

\subsection{Short Vector Module (\texttt{src\_short})}

\begin{description}
    \item[\texttt{SHORT\_GetShortestVector}] Find shortest vectors in a lattice
    \item[\texttt{SHORT\_AutomorphismGroup}] Compute automorphism group from short vectors
    \item[\texttt{SHORT\_CheckPrimeRealizability}] Test realizability over finite fields
\end{description}

\begin{thebibliography}{99}

\bibitem{DutourSikiric2020}
M.~Dutour Sikirić, A.~Haensch, J.~Voight, and W.~P.~J.~van Woerden.
\newblock A canonical form for positive definite matrices.
\newblock \textit{arXiv preprint arXiv:2004.14022}, 2020.
\newblock This paper presents the explicit, deterministic algorithm used in this library for computing canonical forms of positive definite matrices under unimodular integral transformations. The method leverages characteristic sets of short vectors and partition-backtracking graph software (nauty/Traces). Implemented in \texttt{src\_group} for polytope canonicalization and \texttt{src\_latt} for lattice canonical forms.

\bibitem{Allcock2021}
D.~Allcock.
\newblock An alternative to Vinberg's algorithm.
\newblock \textit{arXiv preprint arXiv:2110.03784}, 2021.
\newblock This paper introduces a faster alternative to Vinberg's algorithm for finding fundamental domains of reflection groups acting on hyperbolic space. The edgewalk method is implemented in the Lorentzian module (\texttt{src\_lorentzian}) and can significantly outperform the classical Vinberg algorithm.

\bibitem{Bremner2014}
D.~Bremner, M.~Dutour Sikirić, D.~V.~Pasechnik, T.~Rehn, and A.~Schürmann.
\newblock Computing symmetry groups of polyhedra.
\newblock \textit{arXiv preprint arXiv:1210.0206}, 2012. Published in LMS J. Comput. Math. 17 (2014), 565-581.
\newblock This paper presents algorithms for computing linear, projective, and combinatorial symmetry groups of polyhedra. The methods are implemented in \texttt{src\_group} and form the foundation for automorphism group computations throughout the library.

\bibitem{DutourSikiric2008a}
M.~Dutour Sikirić, A.~Schürmann, and F.~Vallentin.
\newblock Complexity and algorithms for computing Voronoi cells of lattices.
\newblock \textit{arXiv preprint arXiv:0804.0036}, 2008. Published in Math. Comp. 78 (2009), 1713-1731.
\newblock This paper establishes that computing vertices of Voronoi cells is \#P-hard but presents practical algorithms effective for lattices up to dimension 12 and symmetric lattices. Implemented in \texttt{src\_latt} for Delaunay polytope computations.

\bibitem{DutourSikiric2007}
M.~Dutour Sikirić, A.~Schürmann, and F.~Vallentin.
\newblock A generalization of Voronoi's reduction theory and its application.
\newblock \textit{arXiv preprint arXiv:math/0601084}, 2006. Published in Duke Math. J. 142 (2008), 127-164.
\newblock This paper generalizes Voronoi reduction theory to forms with prescribed symmetry constraints and Delone subdivisions. The algorithms are used in \texttt{src\_latt} for computing isoDelaunay domains and lattice reduction with symmetry.

\bibitem{Gangl2013}
H.~Gangl, P.~E.~Gunnells, J.~Hanke, A.~Schürmann, M.~Dutour Sikirić, and D.~Yasaki.
\newblock On the cohomology of linear groups over imaginary quadratic fields.
\newblock \textit{arXiv preprint arXiv:1307.1165}, 2013.
\newblock This paper computes cohomology groups using polyhedral reduction techniques. The T-space methods are implemented in \texttt{src\_latt} and \texttt{src\_perfect} for analyzing perfect forms and lattice structures.

\bibitem{Deza2015}
M.~Deza and M.~Dutour Sikirić.
\newblock Enumeration of the facets of cut polytopes over some highly symmetric graphs.
\newblock \textit{arXiv preprint arXiv:1501.05407}, 2015.
\newblock This paper presents computational results for facet enumeration of cut polytopes, demonstrating large-scale polyhedral computations. The techniques are implemented in \texttt{src\_dualdesc} for MPI-based parallel dual description.

\bibitem{DutourSikiric2007b}
M.~Dutour Sikirić, A.~Schürmann, and F.~Vallentin.
\newblock Classification of eight dimensional perfect forms.
\newblock \textit{arXiv preprint arXiv:math/0609388}, 2006. Published in Electron. Res. Announc. Amer. Math. Soc. 13 (2007), 21-32.
\newblock This paper classifies all 10,916 perfect lattices in dimension 8 using symmetry-exploiting algorithms. The enumeration methods are implemented in \texttt{src\_perfect} and \texttt{src\_dualdesc}.

\bibitem{DutourSikiric2018}
M.~Dutour Sikirić, A.~Schürmann, and F.~Vallentin.
\newblock A simplex algorithm for rational cp-factorization.
\newblock \textit{arXiv preprint arXiv:1807.01382}, 2018. Published in Math. Program. 187 (2021), 483-498.
\newblock This paper presents a simplex-inspired algorithm for rational CP-factorizations and proves that every integral completely positive $2 \times 2$ matrix has an integral cp-factorization. Implemented in \texttt{src\_copos}.

\bibitem{DutourSikiric2022}
M.~Dutour Sikirić.
\newblock The Birkhoff polytope of the groups $F_4$ and $H_4$.
\newblock \textit{arXiv preprint arXiv:2212.08452}, 2022.
\newblock This paper computes facets of Birkhoff polytopes associated with Coxeter groups, refuting previous conjectures. The computational techniques use methods from \texttt{src\_poly} and \texttt{src\_group}.

\bibitem{DutourSikiric2023}
M.~Dutour Sikirić and K.~Hulek.
\newblock Moduli of polarized Enriques surfaces -- computational aspects.
\newblock \textit{arXiv preprint arXiv:2302.01679}, 2023.
\newblock This paper demonstrates applications of algorithms for indefinite quadratic forms and groups to compute the Tits building and classify 87 arithmetic groups underlying moduli spaces. Uses methods from \texttt{src\_indefinite} and \texttt{src\_lorentzian}.

\end{thebibliography}

\end{document}
