// Copyright (C) 2022 Mathieu Dutour Sikiric <mathieu.dutour@gmail.com>
#ifndef SRC_GROUP_MATRIXGROUPAVERAGE_H_
#define SRC_GROUP_MATRIXGROUPAVERAGE_H_

/*
  Builds the smallest vector space containing the space TheBasis and invariant by
  the group generated by LGen.
  Code adapted from DirectSpannEquivariantSpace in the GAP version.
 */
template<typename T>
MyMatrix<T> DirectSpannEquivariantSpace(MyMatrix<T> const& TheBasis, std::vector<MyMatrix<T>> const& LGen) {
  MyMatrix<T> TheMatrixRet = TheBasis;
  while(true) {
    SolutionMatRepetitivee<T> smr(TheBasisRet);
    auto get_update=[&]() -> std::optional<MyVector<T>> {
      int len = TheBasisRet.rows();
      for (int u=0; u<len; u++) {
        MyVector<T> V = GetMatrixRow(TheBasisRet, u);
        for (auto & eGen : LGen) {
          MyVector<T> Vimg = eGen.transpose() * V;
          std::optional<MyVector<T>> opt = smr.GetSolution(Vimg);
          if (!opt) {
            return Vimg;
          }
        }
      }
      return {};
    };
    std::optional<MyVector<T>> opt = get_update();
    if (opt) {
      TheBasisRet = ConcatenateMatVec(TheBasisRet, *opt);
    } else {
      return TheBasisRet;
    }
  }
}


/*
  Compute the average of a vector under the group generated by the generator.
  The code computes the average under the group generated without building the
  full orbit.
  Code adapted from OrbitBarycenter from the GAP version.
 */
template <typename T>
MyVector<T> OrbitBarycenter(MyVector<T> const&a, std::vector<MyMatrix<T>> const& LGen) {
  auto is_invariant=[&]() -> bool {
    for (auto & eGen : LGen) {
      MyVector<T> a_img = eGen.transpose() * a;
      if (a_img != a) {
        return false;
      }
    }
    return true;
  };
  if (is_invariant()) {
    return a;
  }
  // Not invariant, need to build a linear system
  int n_gen = LGen.rows();
  int dim = a.size();
  MyMatrix<T> ListSpann(n_gen, dim);
  for (int i_gen=0; i_gen<n_gen; i_gen++) {
    MyMatrix<T> const& eGen = LGen[i_gen];
    MyVector<T> a_img = eGen.transpose() * a;
    for (int u=0; u<dim; u++) {
      ListSpann(i_gen,u) = a_img(u);
    }
  }
  MyMatrix<T> TheBasis1 = RowReduction(ListSpann);
  MyMatrix<T> TheBasis2 = DirectSpannEquivariantSpace(TheBasis1, LGen);
  int dim_space = TheBasis2.rows();
  MyMatrix<T> TheBigMat(dim_space, n_gen * dim);
  MyVector<T> Vbig(n_gen * dim);
  for (int i_gen=0; i_gen<n_gen; i_gen++) {
    MyMatrix<T> const& eGen = LGen[i_gen];
    MyMatrix<T> diff_M = TheBasis2 * eGen - TheBasis2;
    for (int iRow=0; iRow<dim_space; iRow++) {
      for (int iCol=0; iCol<dim; iCol++) {
        TheBigMat(iRow, iCol + dim * i_gen) = diff_M(iRow,iCol);
      }
    }
    MyVector<T> diff_V = a - eGen.transpose() * a;
    for (int iCol=0; iCol<dim; iCol++) {
      Vbig(iCol + dim * i_gen) = diff_V(iCol);
    }
  }
  std::optional<MyVector<T>> opt = SolutionMat(TheBigMat, Vbig);
  MyVector<T> Alpha = unfold_opt(opt, "Failed to solve the linear system");
  MyVector<T> TheSol = a + TheBasis.transpose() * Alpha;
  return TheSol;
}

// clang-format off
#endif  // SRC_GROUP_MATRIXGROUPAVERAGE_H_
// clang-format on
