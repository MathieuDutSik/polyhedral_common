#ifndef INCLUDE_MATRIX_GROUP_H
#define INCLUDE_MATRIX_GROUP_H

#include "Group.h"
#include "factorizations.h"
#include "MAT_MatrixInt.h"
#include "GRP_GroupFct.h"
#include "PERM_Fct.h"
#include "MatrixGroupBasic.h"



template<typename T>
struct MatrixGroup {
  int n;
  std::vector<MyMatrix<T>> ListGen;
};



template<typename T>
bool IsIdentity(MyMatrix<T> const& M)
{
  int len = M.rows();
  for (int i=0; i<len; i++) {
    for (int j=0; j<len; j++) {
      if (i == j && M(i,j) != 1)
        return false;
      if (i != j && M(i,j) != 0)
        return false;
    }
  }
  return true;
}



template<typename T>
T LinearSpace_GetDivisor(MyMatrix<T> const& TheSpace)
{
  T TheDet=T_abs(DeterminantMat(TheSpace));
  T eDiv=1;
  int n=TheSpace.rows();
  while(true) {
    bool IsOK=true;
    for (int i=0; i<n; i++)
      if (IsOK) {
	MyVector<T> eVect=ZeroVector<T>(n);
	eVect(i)=eDiv;
	bool test=SolutionIntMat(TheSpace, eVect).has_value();
	if (!test)
	  IsOK=false;
      }
    if (IsOK)
      return eDiv;
    if (eDiv > TheDet) {
      std::cerr << "eDiv=" << eDiv << " TheDet=" << TheDet << "\n";
      std::cerr << "TheSpace=\n";
      WriteMatrix(std::cerr, TheSpace);
      std::cerr << "Clear error in LinearSpace_GetDivisor\n";
      throw TerminalException{1};
    }
    eDiv += 1;
  }
}

template<typename T>
MyMatrix<T> MatrixIntegral_GetInvariantSpace(int const& n, std::vector<MyMatrix<T>> const& LGen)
{
  std::vector<MyMatrix<T>> LGenTot;
  for (auto & eGen : LGen) {
    LGenTot.push_back(eGen);
    LGenTot.push_back(Inverse(eGen));
  }
  LGenTot.push_back(IdentityMat<T>(n));
  MyMatrix<T> TheSpace = IdentityMat<T>(n);
  T TheDet = 1;
  while(true) {
    std::vector<MyVector<T>> ConcatSpace;
    for (auto & eGen : LGenTot) {
      MyMatrix<T> TheSpaceImg = TheSpace * eGen;
      for (int i=0; i<n; i++)
        ConcatSpace.push_back(GetMatrixRow(TheSpaceImg,i));
    }
    MyMatrix<T> NewSpace = GetZbasis(MatrixFromVectorFamily(ConcatSpace));
    T NewDet = T_abs(DeterminantMat(NewSpace));
    if (NewDet == TheDet)
      return TheSpace;
    TheSpace = NewSpace;
    TheDet = NewDet;
  }
}



// Compute Orbit of an object of type T2 under
// a group generated by elements of type T1
template<typename T1, typename T2, typename F>
std::vector<T2> OrbitComputation(std::vector<T1> const& ListGen, T2 const& a, const F& f)
{
  std::vector<T2> TheOrbit;
  std::unordered_set<T2> TheSet;
  auto fInsert=[&](T2 const& u) -> void {
    if (TheSet.count(u) == 1)
      return;
    TheOrbit.push_back(u);
    TheSet.insert(u);
  };
  fInsert(a);
  size_t pos = 0;
  while(true) {
    size_t len=TheOrbit.size();
    if (pos == len)
      break;
    for (size_t i=pos; i<len; i++)
      for (auto & eGen : ListGen) {
        T2 u=f(TheOrbit[i],eGen);
        fInsert(u);
      }
    pos = len;
  }
  return TheOrbit;
}

//

template<typename T, typename Telt>
struct ResultGeneratePermutationGroup_Finite {
  int nbRow;
  int siz;
  std::vector<Telt> ListPermGens;
};

template<typename T, typename Telt>
struct FiniteMatrixGroupHelper {
  using Treturn = ResultGeneratePermutationGroup_Finite<T,Telt>;
  int n;
  MyMatrix<T> EXTfaithful;
  std::vector<MyVector<T>> ListV;
  std::unordered_map<MyVector<T>,int> MapV;
};

//

template<typename T, typename Telt>
struct ResultGeneratePermutationGroup_FiniteIsotropic {
  int nbRow;
  int siz;
  std::vector<Telt> ListPermGens;
};

template<typename T, typename Telt>
struct FiniteIsotropicMatrixGroupHelper {
  using Treturn = ResultGeneratePermutationGroup_FiniteIsotropic<T,Telt>;
  int n;
  MyMatrix<T> G;
  MyMatrix<T> EXTfaithful;
  std::vector<MyVector<T>> ListV;
  std::unordered_map<MyVector<T>,int> MapV;
};

//

template<typename T, typename Telt>
struct ResultGeneratePermutationGroup_General {
  int nbRow;
  int siz;
  std::vector<MyMatrix<T>> ListMatrGens;
  std::vector<Telt> ListPermGens;
};

template<typename T, typename Telt>
struct GeneralMatrixGroupHelper {
  using Treturn = ResultGeneratePermutationGroup_General<T,Telt>;
  int n;
};

//

template <typename Thelper>
struct has_determining_ext {
  static const bool value = false;
};

template <typename T, typename Telt>
struct has_determining_ext<FiniteMatrixGroupHelper<T,Telt>> {
  static const bool value = true;
};

template <typename T, typename Telt>
struct has_determining_ext<FiniteIsotropicMatrixGroupHelper<T,Telt>> {
  static const bool value = true;
};



//

template<typename T, typename Telt>
FiniteMatrixGroupHelper<T,Telt> ComputeFiniteMatrixGroupHelper(MyMatrix<T> const& EXT)
{
  std::vector<MyVector<T>> ListV;
  std::unordered_map<MyVector<T>,int> MapV;
  for (int i=0; i<EXT.rows(); i++) {
    MyVector<T> V = GetMatrixRow(EXT,i);
    ListV.push_back(V);
    MapV[V] = i;
  }
  return {int(EXT.cols()), EXT, std::move(ListV), std::move(MapV)};
}

template<typename T, typename Telt>
FiniteIsotropicMatrixGroupHelper<T,Telt> ComputeFiniteIsotropicMatrixGroupHelper(MyMatrix<T> const& G, MyMatrix<T> const& EXT)
{
  std::vector<MyVector<T>> ListV;
  std::unordered_map<MyVector<T>,int> MapV;
  for (int i=0; i<EXT.rows(); i++) {
    MyVector<T> V = GetMatrixRow(EXT,i);
    ListV.push_back(V);
    MapV[V] = i;
  }
  return {int(EXT.cols()), G, EXT, std::move(ListV), std::move(MapV)};
}

template<typename T, typename Telt, typename Thelper>
inline typename std::enable_if<has_determining_ext<Thelper>::value,Telt>::type GetPermutationForFiniteMatrixGroup(Thelper const& helper, MyMatrix<T> const& eMatr)
{
#ifdef DEBUG_MATRIX_GROUP
  //  std::cerr << "Beginning of GetPermutationForFiniteMatrixGroup\n";
  //  std::cerr << "|ListV|=" << helper.ListV.size() << "\n";
  //  for (auto & eV : helper.ListV)
  //    std::cerr << "V=" << StringVectorGAP(eV) << "\n";
  //  std::cerr << "eMat=" << StringMatrixGAP(eMatr) << "\n";
  //  MyMatrix<T> eProd = eMatr * helper.G * eMatr.transpose();
  //  std::cerr << "eProd=" << StringMatrixGAP(eProd) << "\n";
#endif
  using Tidx = typename Telt::Tidx;
  Tidx len = helper.EXTfaithful.rows();
  std::vector<Tidx> V(len);
  for (Tidx i=0; i<len; i++) {
    MyVector<T> Vimg = eMatr.transpose() * helper.ListV[i];
#ifdef DEBUG_MATRIX_GROUP
    //    std::cerr << "i=" << i << " Vimg=" << StringVectorGAP(Vimg) << "\n";
#endif
    V[i] = helper.MapV.at(Vimg);
  }
#ifdef DEBUG_MATRIX_GROUP
  //  std::cerr << "Beginning of GetPermutationForFiniteMatrixGroup\n";
#endif
  return Telt(std::move(V));
}




template<typename T, typename Telt>
void CheckerPairReord(std::vector<T> const& V1, Telt const& g1, std::vector<T> const& V2, Telt const& g2)
{
  size_t len = V1.size();
  std::vector<T> V1reord(len);
  std::vector<T> V2reord(len);
  for (size_t i=0; i<len; i++) {
    size_t pos1 = g1.at(i);
    V1reord[i] = V1[pos1];
    size_t pos2 = g2.at(i);
    V2reord[i] = V2[pos2];
  }
  for (size_t i=1; i<len; i++) {
    if (!(V1reord[i-1] < V1reord[i])) {
      std::cerr << "V1reord is not increasing at i=" << i << "\n";
      throw TerminalException{1};
    }
    if (!(V2reord[i-1] < V2reord[i])) {
      std::cerr << "V2reord is not increasing at i=" << i << "\n";
      throw TerminalException{1};
    }
  }
  if (V1reord != V2reord) {
    std::cerr << "V1reord is not identical to V2reord\n";
    throw TerminalException{1};
  }
  /*
  for (size_t i=0; i<len; i++) {
    T eDiff = V1reord[i] - V2reord[i];
    std::cerr << "i=" << i << " eDiff=" << eDiff << "\n";
    //    std::cerr << "i=" << i << " v1=" << V1reord[i] << " v2=" << V2reord[i] << "\n";
  }
  */
  /*
  std::cerr << "Passed the CheckerPairReord\n";
  std::cerr << "V1reord=\n";
  for (auto& eV : V1reord)
    std::cerr << "V=" << StringVectorGAP(eV) << "\n";
  */
}

template<typename T>
Face GetFace(int const& nbRow, std::vector<MyVector<T>> const& O, MyMatrix<T> const& TheSpace)
{
  size_t Osiz = O.size();
  size_t siz = nbRow + Osiz;
  //  std::cerr << "GetFace : nbRow=" << nbRow << "\n";
  Face eFace(siz);
  for (size_t iO=0; iO<Osiz; iO++) {
    MyVector<T> const& eVect=O[iO];
    std::optional<MyVector<T>> eRes1=SolutionIntMat(TheSpace, eVect);
    if (eRes1) {
      //      std::cerr << "Setting true at iO=" << iO << "\n";
      eFace[nbRow + iO]=1;
    }
  }
  return eFace;
}

template<typename T>
MyVector<T> VectorMod(MyVector<T> const& V, T const& TheMod)
{
  int n = V.size();
  MyVector<T> Vret(n);
  for (int i=0; i<n; i++)
    Vret(i)=ResInt(V(i), TheMod);
  return Vret;
}



template<typename T, typename Telt>
MyMatrix<T> RepresentPermutationAsMatrix(FiniteMatrixGroupHelper<T,Telt> const& helper, Telt const& ePerm)
{
#ifdef DEBUG_MATRIX_GROUP
  std::cerr << "Beginning of RepresentPermutationAsMatrix for FiniteMatrixGroupHelper\n";
#endif
  return FindTransformation(helper.EXTfaithful, helper.EXTfaithful, ePerm);
}

template<typename T, typename Telt>
MyMatrix<T> RepresentPermutationAsMatrix(FiniteIsotropicMatrixGroupHelper<T,Telt> const& helper, Telt const& ePerm)
{
#ifdef DEBUG_MATRIX_GROUP
  std::cerr << "Beginning of RepresentPermutationAsMatrix for FiniteIsotropicMatrixGroupHelper\n";
#endif
  MyMatrix<T> const& Subspace1 = helper.EXTfaithful;
  int n_rows = Subspace1.rows();
  int n_cols = Subspace1.cols();
  MyMatrix<T> Subspace2(n_rows, n_cols);
  for (int i_row=0; i_row<n_rows; i_row++) {
    MyVector<T> V = GetMatrixRow(Subspace1, i_row);
    int j_row = OnPoints(i_row, ePerm);
    AssignMatrixRow(Subspace2, j_row, V);
  }
  std::optional<MyMatrix<T>> opt = ExtendOrthogonalIsotropicIsomorphism(helper.G, Subspace1, helper.G, Subspace2);
  if (!opt) {
    std::cerr << "We should have opt well defined\n";
    throw TerminalException{1};
  }
  return *opt;
}



template<typename T, typename Telt, typename Thelper>
inline typename std::enable_if<has_determining_ext<Thelper>::value,typename Thelper::Treturn>::type MatrixIntegral_GeneratePermutationGroup(std::vector<MyMatrix<T>> const& ListMatrGens, Thelper const& helper, std::vector<MyVector<T>> const& O, T const& TheMod)
{
#ifdef DEBUG_MATRIX_GROUP
  std::cerr << "Beginning of MatrixIntegral_GeneratePermutationGroup\n";
#endif
#ifdef TIMINGS
  std::chrono::time_point<std::chrono::system_clock> time1 = std::chrono::system_clock::now();
#endif
  using Tidx = typename Telt::Tidx;
  int Osiz=O.size();
#ifdef DEBUG_MATRIX_GROUP
  std::cerr << "Osiz=" << Osiz << "\n";
#endif
  int nbRow = helper.EXTfaithful.rows();
  Tidx nbRow_tidx = nbRow;
  int siz=nbRow + Osiz;
  Telt ePermS=Telt(SortingPerm<MyVector<T>,Tidx>(O));
  auto TheAction=[&](MyVector<T> const& eClass, MyMatrix<T> const& eElt) -> MyVector<T> {
    MyVector<T> eVect=eElt.transpose() * eClass;
    return VectorMod(eVect, TheMod);
  };
#ifdef TIMINGS
  std::chrono::time_point<std::chrono::system_clock> time2 = std::chrono::system_clock::now();
  std::cerr << "|SortingPerm|=" << std::chrono::duration_cast<std::chrono::microseconds>(time2 - time1).count() << "\n";
#endif
  Telt ePermSinv=~ePermS;
#ifdef TIMINGS
  std::chrono::time_point<std::chrono::system_clock> time3 = std::chrono::system_clock::now();
  std::cerr << "|ePermSinv|=" << std::chrono::duration_cast<std::chrono::microseconds>(time3 - time2).count() << "\n";
#endif
  std::vector<Telt> ListPermGenProv;
  size_t nbGen=ListMatrGens.size();
  for (size_t iGen=0; iGen<nbGen; iGen++) {
#ifdef TIMINGS
    std::chrono::time_point<std::chrono::system_clock> timeB_1 = std::chrono::system_clock::now();
#endif
    MyMatrix<T> const& eMatrGen=ListMatrGens[iGen];
    Telt ePermGen=GetPermutationForFiniteMatrixGroup<T,Telt,Thelper>(helper, eMatrGen);
#ifdef DEBUG_MATRIX_GROUP
    std::cerr << "iGen=" << iGen << "/" << nbGen << " ePermGen=" << ePermGen << "\n";
#endif
    std::vector<Tidx> v(siz);
    for (Tidx i=0; i<nbRow_tidx; i++)
      v[i]=ePermGen.at(i);
#ifdef TIMINGS
    std::chrono::time_point<std::chrono::system_clock> timeB_2 = std::chrono::system_clock::now();
    std::cerr << "|v 1|=" << std::chrono::duration_cast<std::chrono::microseconds>(timeB_2 - timeB_1).count() << "\n";
#endif
    std::vector<MyVector<T>> ListImage(Osiz);
    // That code below is shorter and it has the same speed as the above.
    // We keep the more complicate because it shows where most of the runtime is: In computing Oprod.
    for (int iV=0; iV<Osiz; iV++)
      ListImage[iV] = TheAction(O[iV], eMatrGen);
#ifdef TIMINGS
    std::chrono::time_point<std::chrono::system_clock> timeB_3 = std::chrono::system_clock::now();
    std::cerr << "|ListImage|=" << std::chrono::duration_cast<std::chrono::microseconds>(timeB_3 - timeB_2).count() << "\n";
#endif
    Telt ePermB=Telt(SortingPerm<MyVector<T>,Tidx>(ListImage));
#ifdef TIMINGS
    std::chrono::time_point<std::chrono::system_clock> timeB_4 = std::chrono::system_clock::now();
    std::cerr << "|SortingPerm|=" << std::chrono::duration_cast<std::chrono::microseconds>(timeB_4 - timeB_3).count() << "\n";
#endif
    Telt ePermBinv = ~ePermB;
#ifdef TIMINGS
    std::chrono::time_point<std::chrono::system_clock> timeB_5 = std::chrono::system_clock::now();
    std::cerr << "|ePermBinv|=" << std::chrono::duration_cast<std::chrono::microseconds>(timeB_5 - timeB_4).count() << "\n";
#endif
    //      std::cerr << "  ePermS=" << ePermS << " ePermB=" << ePermB << "\n";
    // By the construction and above check we have
    // V1reord[i] = V1[g1.at(i)]
    // V2reord[i] = V2[g2.at(i)]
    // We have V1reord = V2reord which gets us
    // V2[i] = V1[g1 * g2^{-1}(i)]
    Telt ePermGenSelect=ePermBinv * ePermS;
#ifdef TIMINGS
    std::chrono::time_point<std::chrono::system_clock> timeB_6 = std::chrono::system_clock::now();
    std::cerr << "|ePermGenSelect|=" << std::chrono::duration_cast<std::chrono::microseconds>(timeB_6 - timeB_5).count() << "\n";
#endif
#ifdef DEBUG_MATRIX_GROUP
    //    std::cerr << "  ePermGenSelect=" << ePermGenSelect << "\n";
#endif
    for (int iO=0; iO<Osiz; iO++) {
      int jO=ePermGenSelect.at(iO);
      v[nbRow+iO]=nbRow+jO;
    }
#ifdef TIMINGS
    std::chrono::time_point<std::chrono::system_clock> timeB_7 = std::chrono::system_clock::now();
    std::cerr << "|v 2|=" << std::chrono::duration_cast<std::chrono::microseconds>(timeB_7 - timeB_6).count() << "\n";
#endif
    Telt eNewPerm(std::move(v));
#ifdef DEBUG_MATRIX_GROUP
    for (int iO=0; iO<Osiz; iO++) {
      MyVector<T> eVect = O[iO];
      MyVector<T> eVectImg1 = TheAction(eVect, eMatrGen);
      size_t pos = eNewPerm.at(iO + nbRow_tidx) - nbRow_tidx;
      MyVector<T> eVectImg2 = O[pos];
      if (eVectImg1 != eVectImg2) {
        std::cerr << "  Inconsistency\n";
        std::cerr << "  iGen=" << iGen << " iO=" << iO << "\n";
        std::cerr << "  eVectImg1=" << StringVectorGAP(eVectImg1) << "\n";
        std::cerr << "  eVectImg2=" << StringVectorGAP(eVectImg2) << "\n";
        throw TerminalException{1};
      }
    }
#endif
    ListPermGenProv.emplace_back(std::move(eNewPerm));
#ifdef TIMINGS
    std::chrono::time_point<std::chrono::system_clock> timeB_8 = std::chrono::system_clock::now();
    std::cerr << "|insert|=" << std::chrono::duration_cast<std::chrono::microseconds>(timeB_8 - timeB_7).count() << "\n";
#endif
  }
#ifdef TIMINGS
  std::chrono::time_point<std::chrono::system_clock> time4 = std::chrono::system_clock::now();
  std::cerr << "|ListPermGenProv|=" << std::chrono::duration_cast<std::chrono::microseconds>(time4 - time3).count() << "\n";
#endif
#ifdef DEBUG_MATRIX_GROUP
  permutalib::Group<Telt,mpz_class> GRPprov(ListPermGenProv, siz);
  std::cerr << "|GRPprov|=" << GRPprov.size() << "\n";
#endif
  return {nbRow, siz, ListPermGenProv};
}



template<typename T, typename Tgroup, typename Thelper>
inline typename std::enable_if<has_determining_ext<Thelper>::value,std::vector<MyMatrix<T>>>::type MatrixIntegral_Stabilizer(
           [[maybe_unused]] typename Thelper::Treturn const& eret,
           Tgroup const& GRPperm, Thelper const& helper, Face const& eFace)
{
#ifdef DEBUG_MATRIX_GROUP
  std::cerr << "Beginning of MatrixIntegral_Stabilizer\n";
#endif
  using Telt=typename Tgroup::Telt;
  using Tidx=typename Telt::Tidx;
  Tgroup eStab=GRPperm.Stabilizer_OnSets(eFace);
#ifdef DEBUG_MATRIX_GROUP
  std::cerr << "  |eStab|=" << eStab.size() << " |eFace|=" << eFace.count() << "\n";
#endif
  std::vector<MyMatrix<T>> ListMatrGen;
  Tidx nbRow_tidx = helper.EXTfaithful.rows();
  for (auto & eGen : eStab.GeneratorsOfGroup()) {
    std::vector<Tidx> v(nbRow_tidx);
    for (Tidx i=0; i<nbRow_tidx; i++)
      v[i]=OnPoints(i, eGen);
    Telt ePerm(std::move(v));
    MyMatrix<T> eMatr=RepresentPermutationAsMatrix(helper, ePerm);
    ListMatrGen.emplace_back(std::move(eMatr));
  }
  return ListMatrGen;
}



template<typename T, typename Tgroup, typename Thelper>
inline typename std::enable_if<has_determining_ext<Thelper>::value,std::optional<MyMatrix<T>>>::type MatrixIntegral_RepresentativeAction(
           [[maybe_unused]] typename Thelper::Treturn const& eret,
           Tgroup const& GRPperm, Thelper const& helper, Face const& eFace1, Face const& eFace2)
{
#ifdef DEBUG_MATRIX_GROUP
  std::cerr << "Beginning of MatrixIntegral_RepresentativeAction\n";
#endif
  using Telt=typename Tgroup::Telt;
  std::optional<Telt> opt=GRPperm.RepresentativeAction_OnSets(eFace1, eFace2);
  if (!opt) {
#ifdef DEBUG_MATRIX_GROUP
    std::cerr << "Exit while loop with proof that no equivalence exists\n";
#endif
    return {};
  }
  MyMatrix<T> eMat=RepresentPermutationAsMatrix(helper, *opt);
#ifdef DEBUG_MATRIX_GROUP
  std::cerr << "eMat=\n";
  WriteMatrix(std::cerr, eMat);
#endif
  return eMat;
}




template<typename T, typename Telt, typename Thelper>
inline typename std::enable_if<(not has_determining_ext<Thelper>::value),ResultGeneratePermutationGroup_General<T,Telt>>::type MatrixIntegral_GeneratePermutationGroup(
           std::vector<MyMatrix<T>> const& ListMatrGens, [[maybe_unused]] Thelper const& helper,
           std::vector<MyVector<T>> const& O, T const& TheMod)
{
#ifdef DEBUG_MATRIX_GROUP
  std::cerr << "Beginning of MatrixIntegral_GeneratePermutationGroup 2\n";
#endif
#ifdef TIMINGS
  std::chrono::time_point<std::chrono::system_clock> time1 = std::chrono::system_clock::now();
#endif
  using Tidx = typename Telt::Tidx;
  int Osiz=O.size();
#ifdef DEBUG_MATRIX_GROUP
  std::cerr << "Osiz=" << Osiz << "\n";
#endif
  int siz=Osiz;
  Telt ePermS=Telt(SortingPerm<MyVector<T>,Tidx>(O));
  auto TheAction=[&](MyVector<T> const& eClass, MyMatrix<T> const& eElt) -> MyVector<T> {
    MyVector<T> eVect=eElt.transpose() * eClass;
    return VectorMod(eVect, TheMod);
  };
#ifdef TIMINGS
  std::chrono::time_point<std::chrono::system_clock> time2 = std::chrono::system_clock::now();
  std::cerr << "|SortingPerm|=" << std::chrono::duration_cast<std::chrono::microseconds>(time2 - time1).count() << "\n";
#endif
  Telt ePermSinv=~ePermS;
#ifdef TIMINGS
  std::chrono::time_point<std::chrono::system_clock> time3 = std::chrono::system_clock::now();
  std::cerr << "|ePermSinv|=" << std::chrono::duration_cast<std::chrono::microseconds>(time3 - time2).count() << "\n";
#endif
  std::vector<Telt> ListPermGenProv;
  size_t nbGen=ListMatrGens.size();
  for (size_t iGen=0; iGen<nbGen; iGen++) {
#ifdef TIMINGS
    std::chrono::time_point<std::chrono::system_clock> timeB_1 = std::chrono::system_clock::now();
#endif
    MyMatrix<T> const& eMatrGen=ListMatrGens[iGen];
#ifdef DEBUG_MATRIX_GROUP
    std::cerr << "iGen=" << iGen << "/" << nbGen << "\n";
#endif
    std::vector<Tidx> v(siz);
#ifdef TIMINGS
    std::chrono::time_point<std::chrono::system_clock> timeB_2 = std::chrono::system_clock::now();
    std::cerr << "|v 1|=" << std::chrono::duration_cast<std::chrono::microseconds>(timeB_2 - timeB_1).count() << "\n";
#endif
    std::vector<MyVector<T>> ListImage(Osiz);
    // That code below is shorter and it has the same speed as the above.
    // We keep the more complicate because it shows where most of the runtime is: In computing Oprod.
    for (int iV=0; iV<Osiz; iV++)
      ListImage[iV] = TheAction(O[iV], eMatrGen);
#ifdef TIMINGS
    std::chrono::time_point<std::chrono::system_clock> timeB_3 = std::chrono::system_clock::now();
    std::cerr << "|ListImage|=" << std::chrono::duration_cast<std::chrono::microseconds>(timeB_3 - timeB_2).count() << "\n";
#endif
    Telt ePermB=Telt(SortingPerm<MyVector<T>,Tidx>(ListImage));
#ifdef TIMINGS
    std::chrono::time_point<std::chrono::system_clock> timeB_4 = std::chrono::system_clock::now();
    std::cerr << "|SortingPerm|=" << std::chrono::duration_cast<std::chrono::microseconds>(timeB_4 - timeB_3).count() << "\n";
#endif
    Telt ePermBinv = ~ePermB;
#ifdef TIMINGS
    std::chrono::time_point<std::chrono::system_clock> timeB_5 = std::chrono::system_clock::now();
    std::cerr << "|ePermBinv|=" << std::chrono::duration_cast<std::chrono::microseconds>(timeB_5 - timeB_4).count() << "\n";
#endif
    //      std::cerr << "  ePermS=" << ePermS << " ePermB=" << ePermB << "\n";
    // By the construction and above check we have
    // V1reord[i] = V1[g1.at(i)]
    // V2reord[i] = V2[g2.at(i)]
    // We have V1reord = V2reord which gets us
    // V2[i] = V1[g1 * g2^{-1}(i)]
    Telt ePermGenSelect=ePermBinv * ePermS;
#ifdef TIMINGS
    std::chrono::time_point<std::chrono::system_clock> timeB_6 = std::chrono::system_clock::now();
    std::cerr << "|ePermGenSelect|=" << std::chrono::duration_cast<std::chrono::microseconds>(timeB_6 - timeB_5).count() << "\n";
#endif
    ListPermGenProv.emplace_back(std::move(ePermGenSelect));
#ifdef TIMINGS
    std::chrono::time_point<std::chrono::system_clock> timeB_7 = std::chrono::system_clock::now();
    std::cerr << "|insert|=" << std::chrono::duration_cast<std::chrono::microseconds>(timeB_7 - timeB_6).count() << "\n";
#endif
  }
#ifdef TIMINGS
  std::chrono::time_point<std::chrono::system_clock> time4 = std::chrono::system_clock::now();
  std::cerr << "|ListPermGenProv|=" << std::chrono::duration_cast<std::chrono::microseconds>(time4 - time3).count() << "\n";
#endif
  return {0,siz,ListMatrGens,std::move(ListPermGenProv)};
}

template<typename T, typename Tgroup, typename Thelper>
inline typename std::enable_if<(not has_determining_ext<Thelper>::value),std::vector<MyMatrix<T>>>::type MatrixIntegral_Stabilizer(
           typename Thelper::Treturn const& eret,
           [[maybe_unused]] Tgroup const& GRPperm, Thelper const& helper, Face const& eFace)
{
#ifdef DEBUG_MATRIX_GROUP
  std::cerr << "Beginning of MatrixIntegral_Stabilizer 2\n";
#endif
  using Telt=typename Tgroup::Telt;
  using Tint=typename Tgroup::Tint;
  MyMatrix<T> id_matr = IdentityMat<T>(helper.n);
  std::vector<MyMatrix<T>> LStabMatrGen = permutalib::StabilizerMatrixPermSubset<Telt,MyMatrix<T>,Tint>(eret.ListMatrGens, eret.ListPermGens, id_matr, eFace);
  return LStabMatrGen;
}



template<typename T, typename Tgroup, typename Thelper>
inline typename std::enable_if<(not has_determining_ext<Thelper>::value),std::optional<MyMatrix<T>>>::type MatrixIntegral_RepresentativeAction(
           typename Thelper::Treturn const& eret,
           [[maybe_unused]] Tgroup const& GRPperm, Thelper const& helper,
           Face const& eFace1, Face const& eFace2)
{
#ifdef DEBUG_MATRIX_GROUP
  std::cerr << "Beginning of MatrixIntegral_Stabilizer 2\n";
#endif
  using Telt=typename Tgroup::Telt;
  using Tint=typename Tgroup::Tint;
  MyMatrix<T> id_matr = IdentityMat<T>(helper.n);
  std::optional<MyMatrix<T>> opt = permutalib::RepresentativeActionMatrixPermSubset<Telt,MyMatrix<T>,Tint>(eret.ListMatrGens, eret.ListPermGens, id_matr, eFace1, eFace2);
  return opt;
}















// The space must be defining a finite index subgroup of T^n
template<typename T, typename Tgroup, typename Thelper>
std::vector<MyMatrix<T>> LinearSpace_ModStabilizer(std::vector<MyMatrix<T>> const& ListMatr, Thelper const& helper, MyMatrix<T> const& TheSpace, T const& TheMod)
{
  using Telt = typename Tgroup::Telt;
  using Treturn = typename Thelper::Treturn;
  int n=helper.n;
  MyMatrix<T> ModSpace=TheMod * IdentityMat<T>(n);
#ifdef DEBUG_MATRIX_GROUP
  std::cerr << "TheMod=" << TheMod << "  n=" << n << "\n";
  //  std::cerr << "TheSpace=\n";
  //  WriteMatrix(std::cerr, TheSpace);
#endif
  MyMatrix<T> TheSpaceMod=Concatenate(TheSpace, ModSpace);
  CanSolIntMat<T> eCan=ComputeCanonicalFormFastReduction(TheSpaceMod);
  std::function<MyVector<T>(MyVector<T> const&,MyMatrix<T> const&)> TheAction=[&](MyVector<T> const& eClass, MyMatrix<T> const& eElt) -> MyVector<T> {
    MyVector<T> eVect=eElt.transpose() * eClass;
    return VectorMod(eVect, TheMod);
  };
  auto IsStabilizing=[&](std::vector<MyMatrix<T>> const& ListMatr) -> std::optional<MyVector<T>> {
    for (int i=0; i<n; i++) {
      MyVector<T> eVect=GetMatrixRow(TheSpace, i);
      for (auto & eGen : ListMatr) {
	MyVector<T> eVectG=eGen.transpose() * eVect;
        std::optional<MyVector<T>> eRes=SolutionIntMat(TheSpaceMod, eVectG);
	bool test=CanTestSolutionIntMat(eCan, eVectG);
	if (test != eRes.has_value()) {
	  std::cerr << "Inconsistency of result between two SolutionIntMat functions\n";
	  throw TerminalException{1};
	}
	if (!eRes) {
	  MyVector<T> V=VectorMod(eVect, TheMod);
#ifdef DEBUG_MATRIX_GROUP
          std::cerr << "i=" << i << "  eVect=" << StringVectorGAP(eVect) << "\n";
	  std::cerr << "V=" << StringVectorGAP(V) << "\n";
#endif
	  return V;
	}
      }
    }
    return {};
  };
  std::vector<MyMatrix<T>> ListMatrRet = ListMatr;
  while(true) {
#ifdef TIMINGS
    std::chrono::time_point<std::chrono::system_clock> time1 = std::chrono::system_clock::now();
#endif
    std::optional<MyVector<T>> opt = IsStabilizing(ListMatrRet);
#ifdef TIMINGS
    std::chrono::time_point<std::chrono::system_clock> time2 = std::chrono::system_clock::now();
    std::cerr << "|IsStabilizing|=" << std::chrono::duration_cast<std::chrono::microseconds>(time2 - time1).count() << "\n";
#endif
    if (!opt) {
#ifdef DEBUG_MATRIX_GROUP
      std::cerr << "Exiting the loop\n";
#endif
      break;
    }
    const MyVector<T>& V = *opt;
    std::vector<MyVector<T>> O=OrbitComputation(ListMatrRet, V, TheAction);
#ifdef TIMINGS
    std::chrono::time_point<std::chrono::system_clock> time3 = std::chrono::system_clock::now();
    std::cerr << "|OrbitComputation|=" << std::chrono::duration_cast<std::chrono::microseconds>(time3 - time2).count() << "\n";
#endif

    Treturn eret = MatrixIntegral_GeneratePermutationGroup<T,Telt,Thelper>(ListMatrRet, helper, O, TheMod);


    Tgroup GRPwork(eret.ListPermGens, eret.siz);
    Face eFace = GetFace(eret.nbRow, O, TheSpaceMod);


    ListMatrRet = MatrixIntegral_Stabilizer<T,Tgroup,Thelper>(eret, GRPwork, helper, eFace);
  }
  return ListMatrRet;
}


template<typename T>
using ResultTestModEquivalence = std::pair<std::vector<MyMatrix<T>>, MyMatrix<T>>;

/*
  We need a number of separate functions:
  ---The list of matrices has to be separated from the helper data like the EXTfaithful
  ---Function that creates the permutation representation given the ListMatrMat and the helper
  ---A function for computing the 


 */
template<typename T, typename Tgroup, typename Thelper>
std::optional<ResultTestModEquivalence<T>> LinearSpace_ModEquivalence(std::vector<MyMatrix<T>> const& ListMatr, Thelper const& helper, MyMatrix<T> const& TheSpace1, MyMatrix<T> const& TheSpace2, T const& TheMod)
{
  using Telt=typename Tgroup::Telt;
  using Treturn = typename Thelper::Treturn;
  int n=TheSpace1.rows();
#ifdef DEBUG_MATRIX_GROUP
  std::cerr << "------------------------------------------------------\n";
  std::cerr << "LinearSpace_ModEquivalence, TheMod=" << TheMod << "\n";
  std::cerr << "TheSpace1=\n";
  WriteMatrix(std::cerr, TheSpace1);
  std::cerr << "TheSpace2=\n";
  WriteMatrix(std::cerr, TheSpace2);
  std::cerr << "det(TheSpace1)=" << DeterminantMat(TheSpace1) << " det(TheSpace2)=" << DeterminantMat(TheSpace2) << "\n";
#endif
  MyMatrix<T> ModSpace = TheMod * IdentityMat<T>(n);
  MyMatrix<T> TheSpace1Mod = Concatenate(TheSpace1, ModSpace);
  MyMatrix<T> TheSpace2Mod = Concatenate(TheSpace2, ModSpace);
  std::vector<MyMatrix<T>> ListMatrRet = ListMatr;
  MyMatrix<T> eElt=IdentityMat<T>(n);
  auto TheAction=[&](MyVector<T> const& eClass, MyMatrix<T> const& eElt) -> MyVector<T> {
    MyVector<T> eVect=eElt.transpose() * eClass;
    return VectorMod(eVect, TheMod);
  };
  auto IsEquiv=[&](MyMatrix<T> const& eEquiv) -> std::optional<MyVector<T>> {
    MyMatrix<T> TheSpace1img = TheSpace1 * eEquiv;
    for (int i=0; i<n; i++) {
      MyVector<T> eVect = GetMatrixRow(TheSpace1img, i);
      std::optional<MyVector<T>> eRes = SolutionIntMat(TheSpace2Mod, eVect);
      if (!eRes) {
	MyVector<T> V = VectorMod(eVect, TheMod);
#ifdef DEBUG_MATRIX_GROUP
        std::cerr << "   i=" << i << " eVect=" << StringVectorGAP(eVect) << "\n";
        std::cerr << "   V=" << StringVectorGAP(V) << "\n";
        std::cerr << "   eEquiv=\n";
        WriteMatrix(std::cerr, eEquiv);
#endif
	return V;
      }
    }
    return {};
  };
  auto IsStabilizing=[&](std::vector<MyMatrix<T>> const& ListMat) -> std::optional<MyVector<T>> {
    for (auto &eGen : ListMat) {
      MyMatrix<T> TheSpace2img = TheSpace2 * eGen;
      for (int i=0; i<n; i++) {
        MyVector<T> eVect=GetMatrixRow(TheSpace2img, i);
        std::optional<MyVector<T>> eRes=SolutionIntMat(TheSpace2Mod, eVect);
        if (!eRes)
          return VectorMod(eVect, TheMod);
      }
    }
    return {};
  };
  while(true) {
    std::optional<MyVector<T>> test1=IsEquiv(eElt);
    std::optional<MyVector<T>> test2=IsStabilizing(ListMatrRet);
    if (!test1 && !test2) {
#ifdef DEBUG_MATRIX_GROUP
      std::cerr << "eElt and GRPwork are correct. Exiting\n";
#endif
      ResultTestModEquivalence<T> res{ListMatrRet, eElt};
      return res;
    }
    if (test1) {
      MyVector<T> const& V = *test1;
#ifdef DEBUG_MATRIX_GROUP
      std::cerr << "V =";
      WriteVector(std::cerr, V);
#endif
      std::vector<MyVector<T>> O = OrbitComputation(ListMatrRet, V, TheAction);


      Treturn eret = MatrixIntegral_GeneratePermutationGroup<T,Telt,Thelper>(ListMatrRet, helper, O, TheMod);
      Tgroup GRPperm(eret.ListPermGens, eret.siz);

      MyMatrix<T> TheSpace1work = TheSpace1 * eElt;
      MyMatrix<T> TheSpace1workMod = Concatenate(TheSpace1work, ModSpace);
#ifdef DEBUG_MATRIX_GROUP
      std::cerr << "eElt=\n";
      WriteMatrix(std::cerr, eElt);
#endif
      Face eFace1 = GetFace(eret.nbRow, O, TheSpace1workMod);
      Face eFace2 = GetFace(eret.nbRow, O, TheSpace2Mod);
      std::cerr << "nbRow=" << eret.nbRow << " eFace1=" << StringFace(eFace1) << " eFace2=" << StringFace(eFace2) << "\n";
      if (eFace1.count() == 0 && eFace2.count() == 0) {
        std::cerr << "Error in LinearSpace_ModEquivalence. |eFace1| = |eFace2| = 0\n";
        std::cerr << "Clear bug\n";
        throw TerminalException{1};
      }
      std::optional<MyMatrix<T>> opt = MatrixIntegral_RepresentativeAction<T,Tgroup,Thelper>(eret, GRPperm, helper, eFace1, eFace2);
      if (!opt) {
#ifdef DEBUG_MATRIX_GROUP
        std::cerr << "Exit while loop with proof that no equivalence exists\n";
#endif
        return {};
      }
      MyMatrix<T> const& M = *opt;
#ifdef DEBUG_MATRIX_GROUP
      Treturn fret = MatrixIntegral_GeneratePermutationGroup<T,Telt,Thelper>({M}, helper, O, TheMod);
      if (fret.ListPermGens.size() != 1) {
        std::cerr << "ListPermGens does not have the right length\n";
        throw TerminalException{1};
      }
      Telt ePerm = fret.ListPermGens[0];
      Face eFace1_img = OnFace(eFace1, ePerm);
      if (eFace1_img != eFace2) {
        std::cerr << "eFace1 not maššed to eFace2\n";
        std::cerr << "|eFace1|=" << eFace1.size() << "\n";
        std::cerr << "nbRow=" << fret.nbRow << " siz=" << fret.siz << "\n";
        std::cerr << "eFace1_img=" << StringFace(eFace1_img) << "\n";
        throw TerminalException{1};
      }
#endif
      ListMatrRet = MatrixIntegral_Stabilizer<T,Tgroup,Thelper>(eret, GRPperm, helper, eFace2);
      eElt = eElt * M;
    } else {
      MyVector<T> const& V = *test2;
      std::vector<MyVector<T>> O = OrbitComputation(ListMatrRet, V, TheAction);
      Treturn eret = MatrixIntegral_GeneratePermutationGroup<T,Telt,Thelper>(ListMatrRet, helper, O, TheMod);
      Tgroup GRPperm(eret.ListPermGens, eret.siz);
      Face eFace2 = GetFace(eret.nbRow, O, TheSpace2Mod);
      ListMatrRet = MatrixIntegral_Stabilizer<T,Tgroup,Thelper>(eret, GRPperm, helper, eFace2);
    }
  }
}




template<typename T, typename Tgroup, typename Thelper>
std::vector<MyMatrix<T>> LinearSpace_Stabilizer(std::vector<MyMatrix<T>> const& ListMatr, Thelper const& helper, MyMatrix<T> const& TheSpace)
{
  int n=helper.n;
#ifdef DEBUG_MATRIX_GROUP
  //  std::cerr << "TheSpace=\n";
  //  WriteMatrixGAP(std::cerr, TheSpace);
  //  std::cerr << "\n";
  std::cerr << "det(TheSpace)=" << DeterminantMat(TheSpace) << "\n";
#endif
  auto IsStabilizing=[&](std::vector<MyMatrix<T>> const& LMat) -> bool {
    for (int i=0; i<n; i++) {
      MyVector<T> eVect=GetMatrixRow(TheSpace, i);
      for (auto & eGen : LMat) {
	MyVector<T> eVectG=eGen.transpose() * eVect;
        std::optional<MyVector<T>> eRes=SolutionIntMat(TheSpace, eVectG);
	if (!eRes) {
	  return false;
	}
      }
    }
#ifdef DEBUG_MATRIX_GROUP
    std::cerr << "Leaving IsStabilzing: true\n";
#endif
    return true;
  };
  if (IsStabilizing(ListMatr))
    return ListMatr;
  T LFact=LinearSpace_GetDivisor(TheSpace);
  std::vector<T> eList=FactorsInt(LFact);
  int siz=eList.size();
#ifdef DEBUG_MATRIX_GROUP
  std::cerr << "LFact=" << LFact << " siz=" << siz << "\n";
#endif
  std::vector<MyMatrix<T>> ListMatrRet = ListMatr;
  for (int i=1; i<=siz; i++) {
    T TheMod=1;
    for (int j=0; j<i; j++)
      TheMod *= eList[j];
    ListMatrRet = LinearSpace_ModStabilizer<T,Tgroup>(ListMatrRet, helper, TheSpace, TheMod);
    if (IsStabilizing(ListMatrRet))
      return ListMatrRet;
  }
  if (!IsStabilizing(ListMatrRet)) {
    std::cerr << "Error in LinearSpace_Stabilizer\n";
    throw TerminalException{1};
  }
  return ListMatrRet;
}



template<typename T, typename Tgroup, typename Thelper>
std::optional<MyMatrix<T>> LinearSpace_Equivalence(std::vector<MyMatrix<T>> const& ListMatr, Thelper const& helper, MyMatrix<T> const& InSpace1, MyMatrix<T> const& InSpace2)
{
  static_assert(is_ring_field<T>::value, "Requires T to be a field in LinearSpace_Equivalence");
#ifdef DEBUG_MATRIX_GROUP
  std::cerr << "Beginning of LinearSpace_Equivalence\n";
  std::cerr << "InSpace1=\n";
  WriteMatrix(std::cerr, InSpace1);
  std::cerr << "InSpace2=\n";
  WriteMatrix(std::cerr, InSpace2);
  std::cerr << "Det(InSpace1)=" << DeterminantMat(InSpace1) << " Det(InSpace2)=" << DeterminantMat(InSpace2) << "\n";
#endif
  FractionMatrix<T> eRec1=RemoveFractionMatrixPlusCoeff(InSpace1);
  FractionMatrix<T> eRec2=RemoveFractionMatrixPlusCoeff(InSpace2);
#ifdef DEBUG_MATRIX_GROUP
  std::cerr << "eRec1.TheMult=" << eRec1.TheMult << " eRec2.TheMult=" << eRec2.TheMult << "\n";
#endif
  if (eRec1.TheMult != eRec2.TheMult)
      return {};
  MyMatrix<T> const& TheSpace1 = eRec1.TheMat;
  MyMatrix<T> const& TheSpace2 = eRec2.TheMat;
  //
  int n=TheSpace1.rows();
  T LFact1=LinearSpace_GetDivisor(TheSpace1);
  T LFact2=LinearSpace_GetDivisor(TheSpace2);
#ifdef DEBUG_MATRIX_GROUP
  std::cerr << "LFact1 = " << LFact1 << "\n";
  std::cerr << "LFact2 = " << LFact2 << "\n";
#endif
  if (LFact1 != LFact2) {
    return {};
  }
  std::vector<T> eList=FactorsInt(LFact1);
#ifdef DEBUG_MATRIX_GROUP
  std::cerr << "eList =";
  for (auto & eVal : eList)
    std::cerr << " " << eVal;
  std::cerr << "\n";
#endif
  auto IsEquivalence=[&](MyMatrix<T> const& eEquiv) -> bool {
    for (int i=0; i<n; i++) {
      MyVector<T> eVect=GetMatrixRow(TheSpace1, i);
      MyVector<T> eVectG=eEquiv.transpose() * eVect;
      std::optional<MyVector<T>> eRes=SolutionIntMat(TheSpace2, eVectG);
      if (!eRes)
	return false;
    }
    return true;
  };
  std::vector<MyMatrix<T>> ListMatrWork = ListMatr;
  int siz=eList.size();
  std::vector<MyMatrix<T>> ListMatrRet = ListMatr;
  MyMatrix<T> eElt=IdentityMat<T>(n);
  for (int i=1; i<=siz; i++) {
    if (IsEquivalence(eElt))
      return eElt;
    T TheMod=1;
    for (int j=0; j<i; j++)
      TheMod *= eList[j];
    MyMatrix<T> TheSpace1Img=TheSpace1 * eElt;
    std::optional<ResultTestModEquivalence<T>> opt = LinearSpace_ModEquivalence<T,Tgroup,Thelper>(ListMatrWork, helper, TheSpace1Img, TheSpace2, TheMod);
    if (!opt) {
#ifdef DEBUG_MATRIX_GROUP
      std::cerr << "LinearSpace_ModEquivalence failed so we exit here\n";
#endif
      return {};
    }
    eElt = eElt * (opt->second);
    ListMatrWork = opt->first;
  }
  if (!IsEquivalence(eElt)) {
    std::cerr << "Error in LinearSpace_Equivalence\n";
    throw TerminalException{1};
  }
  return eElt;
}


template<typename T,typename Tgroup>
std::vector<MyMatrix<T>> LinPolytopeIntegral_Automorphism_Subspaces(std::vector<MyMatrix<T>> const& ListMatr, MyMatrix<T> const& EXTfaithful)
{
  static_assert(is_ring_field<T>::value, "Requires T to be a field in LinPolytopeIntegral_Automorphism_Subspaces");
  using Telt=typename Tgroup::Telt;
  MyMatrix<T> eBasis = GetZbasis(EXTfaithful);
  MyMatrix<T> InvBasis = Inverse(eBasis);
  MyMatrix<T> EXTbas = EXTfaithful * InvBasis;
  std::vector<MyMatrix<T>> ListMatrGens;
  for (auto & eGen : ListMatr) {
    MyMatrix<T> NewGen = eBasis * eGen * InvBasis;
    if (!IsIntegralMatrix(NewGen)) {
      std::cerr << "Clear error in the code\n";
      throw TerminalException{1};
    }
    ListMatrGens.push_back(NewGen);
  }
  FiniteMatrixGroupHelper<T,Telt> helper = ComputeFiniteMatrixGroupHelper<T,Telt>(EXTbas);
  MyMatrix<T> LattToStab=RemoveFractionMatrix(Inverse(eBasis));

  std::vector<MyMatrix<T>> LMat = LinearSpace_Stabilizer<T,Tgroup>(ListMatrGens, helper, LattToStab);
  std::vector<MyMatrix<T>> ListMatrGensB;
  for (auto & eGen : LMat) {
    MyMatrix<T> NewGen = InvBasis * eGen * eBasis;
    if (!IsIntegralMatrix(NewGen)) {
      std::cerr << "Clear error in the code\n";
      throw TerminalException{1};
    }
    ListMatrGensB.push_back(NewGen);
  }
  return ListMatrGensB;
}


template<typename T, typename Tgroup>
std::optional<MyMatrix<T>> LinPolytopeIntegral_Isomorphism_Method4(MyMatrix<T> const& EXT1_T, MyMatrix<T> const& EXT2_T, Tgroup const& GRP1, typename Tgroup::Telt const& ePerm, std::function<bool(MyMatrix<T>)> const& IsMatrixCorrect)
{
  using Telt=typename Tgroup::Telt;
  for (auto & fPerm : GRP1) {
    Telt eEquivCand=fPerm*ePerm;
    MyMatrix<T> eBigMat=FindTransformation(EXT1_T, EXT2_T, eEquivCand);
    if (IsMatrixCorrect(eBigMat))
      return eBigMat;
  }
  return {};
}

template<typename T, typename Tgroup>
Tgroup LinPolytopeIntegral_Stabilizer_Method4(MyMatrix<T> const& EXT_T, Tgroup const& GRPisom, std::function<bool(MyMatrix<T>)> const& IsMatrixCorrect)
{
  static_assert(is_ring_field<T>::value, "Requires T to be a field in LinPolytopeIntegral_Stabilizer_Method4");
  using Telt=typename Tgroup::Telt;
  int nbVert=EXT_T.rows();
  std::vector<Telt> generatorList;
  Tgroup GRPret(nbVert);
  auto fInsert=[&](Telt const& ePerm) -> void {
    bool test=GRPret.isin(ePerm);
    if (!test) {
      generatorList.push_back(ePerm);
      GRPret = Tgroup(generatorList, nbVert);
    }
  };
  for (auto & ePerm : GRPisom) {
    MyMatrix<T> eBigMat=FindTransformation(EXT_T, EXT_T, ePerm);
    if (IsMatrixCorrect(eBigMat))
      fInsert(ePerm);
  }
  return GRPret;
}

template<typename T, typename Tgroup>
Tgroup LinPolytopeIntegral_Stabilizer_Method8(MyMatrix<T> const& EXT_T, Tgroup const& GRPisom)
{
  static_assert(is_ring_field<T>::value, "Requires T to be a field in LinPolytopeIntegral_Stabilizer_Method8");
  using Telt=typename Tgroup::Telt;
  int nbVert=EXT_T.rows();
  std::vector<MyMatrix<T>> ListMatrGen;
  for (auto & eGen : GRPisom.GeneratorsOfGroup()) {
    MyMatrix<T> eMat=FindTransformation(EXT_T, EXT_T, eGen);
    ListMatrGen.push_back(eMat);
  }
  using Thelper = FiniteMatrixGroupHelper<T,Telt>;
  Thelper helper = ComputeFiniteMatrixGroupHelper<T,Telt>(EXT_T);
  std::vector<MyMatrix<T>> ListMatr = LinPolytopeIntegral_Automorphism_Subspaces<T,Tgroup>(ListMatrGen, EXT_T);
  std::vector<Telt> ListPermGens;
  for (auto & eMatr : ListMatr)
    ListPermGens.push_back(GetPermutationForFiniteMatrixGroup<T,Telt,Thelper>(helper, eMatr));
  return Tgroup(ListPermGens, nbVert);
}








template<typename T,typename Tgroup>
std::optional<MyMatrix<T>> LinPolytopeIntegral_Isomorphism_Subspaces(MyMatrix<T> const& EXT1_T, MyMatrix<T> const& EXT2_T, std::vector<MyMatrix<T>> const& ListMatrGens2, typename Tgroup::Telt const& eEquiv)
{
  static_assert(is_ring_field<T>::value, "Requires T to be a field in LinPolytopeIntegral_Isomorphism_Subspaces");
#ifdef DEBUG_MATRIX_GROUP
  std::cerr << "Beginning of LinPolytopeIntegral_Isomorphism_Subspaces\n";
#endif
  using Telt=typename Tgroup::Telt;
  MyMatrix<T> eBasis1=GetZbasis(EXT1_T);
  MyMatrix<T> eBasis2=GetZbasis(EXT2_T);
  MyMatrix<T> InvBasis1=Inverse(eBasis1);
  MyMatrix<T> InvBasis2=Inverse(eBasis2);
  MyMatrix<T> EXTbas1=EXT1_T*InvBasis1;
  MyMatrix<T> EXTbas2=EXT2_T*InvBasis2;
#ifdef DEBUG_MATRIX_GROUP
  std::cerr << "EXT1_T=\n";
  WriteMatrix(std::cerr, EXT1_T);
  std::cerr << "EXT2_T=\n";
  WriteMatrix(std::cerr, EXT2_T);
  if (EXT1_T.rows() == EXT1_T.cols()) {
    std::cerr << "det(EXT1_T)=" << DeterminantMat(EXT1_T) << "\n";
  }
  if (EXT2_T.rows() == EXT2_T.cols()) {
    std::cerr << "det(EXT2_T)=" << DeterminantMat(EXT2_T) << "\n";
  }
  std::cerr << "eBasis1=\n";
  WriteMatrix(std::cerr, eBasis1);
  std::cerr << "eBasis2=\n";
  WriteMatrix(std::cerr, eBasis2);
  std::cerr << "EXTbas1=\n";
  WriteMatrix(std::cerr, EXTbas1);
  std::cerr << "EXTbas2=\n";
  WriteMatrix(std::cerr, EXTbas2);
#endif
  //
  MyMatrix<T> TheMatEquiv=FindTransformation(EXTbas1, EXTbas2, eEquiv);
#ifdef DEBUG_MATRIX_GROUP
  std::cerr << "TheMatEquiv=\n";
  WriteMatrix(std::cerr, TheMatEquiv);
#endif
  std::vector<MyMatrix<T>> ListMatrGen;
  for (auto & eGen : ListMatrGens2) {
    MyMatrix<T> NewGen = eBasis2 * eGen * InvBasis2;
    ListMatrGen.push_back(NewGen);
  }
  FiniteMatrixGroupHelper<T,Telt> helper = ComputeFiniteMatrixGroupHelper<T,Telt>(EXTbas2);
  MyMatrix<T> eLatt1=Inverse(eBasis1) * TheMatEquiv;
  MyMatrix<T> eLatt2=Inverse(eBasis2);
#ifdef DEBUG_MATRIX_GROUP
  std::cerr << "eLatt1=\n";
  WriteMatrix(std::cerr, eLatt1);
  std::cerr << "eLatt2=\n";
  WriteMatrix(std::cerr, eLatt2);
#endif
  std::optional<MyMatrix<T>> eSpaceEquiv=LinearSpace_Equivalence<T,Tgroup>(ListMatrGen, helper, eLatt1, eLatt2);
  if (!eSpaceEquiv)
    return {};
  MyMatrix<T> eMatFinal=InvBasis1 * TheMatEquiv * (*eSpaceEquiv) * eBasis2;
  if (!IsIntegralMatrix(eMatFinal)) {
    std::cerr << "eMatFinal should be integral\n";
    throw TerminalException{1};
  }
  return eMatFinal;
}


// GRP1 is a group of automorphism preserving EXT1_T
// ePerm is a transformation mapping EXT1 to EXT2.
// We are searching for a transformation h in GRP1 such that
// h * ePerm is an integral transformation.
template<typename T, typename Tgroup>
std::optional<MyMatrix<T>> LinPolytopeIntegral_Isomorphism_Method8(MyMatrix<T> const& EXT1_T, MyMatrix<T> const& EXT2_T, Tgroup const& GRP1, typename Tgroup::Telt const& ePerm)
{
  using Telt = typename Tgroup::Telt;
  std::vector<MyMatrix<T>> ListMatrGens;
  std::vector<Telt> LGen = GRP1.GeneratorsOfGroup();
  for (auto & eGen : LGen) {
    Telt ePermGen=(~ePerm) * eGen * ePerm;
    MyMatrix<T> eMatr=FindTransformation(EXT2_T, EXT2_T, ePermGen);
    ListMatrGens.push_back(eMatr);
  }
  return LinPolytopeIntegral_Isomorphism_Subspaces<T,Tgroup>(EXT1_T, EXT2_T, ListMatrGens, ePerm);
}






#endif
