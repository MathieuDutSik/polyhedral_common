#ifndef MATRIX_GROUP_INCLUDE
#define MATRIX_GROUP_INCLUDE

#include "factorizations.h"
#include "MAT_MatrixInt.h"
#include "GRP_GroupFct.h"
#include "PERM_Fct.h"

template<typename T>
struct resultFT {
  bool test;
  MyMatrix<T> eMat;
};





template<typename T, typename Telt>
resultFT<T> FindTransformationGeneral(MyMatrix<T> const& EXT1, MyMatrix<T> const& EXT2, Telt const& ePerm)
{
  if (EXT1.cols() != EXT2.cols() )
    return {false, {}};
  if (EXT1.rows() != EXT2.rows() )
    return {false, {}};
  int nbCol=EXT1.cols();
  int nbRow=EXT1.rows();
  SelectionRowCol<T> eSelect=TMat_SelectRowCol(EXT1);
  int eRank=eSelect.TheRank;
  if (eRank != nbCol)
    return {false, {}};
  MyMatrix<T> eMat1(nbCol, nbCol);
  MyMatrix<T> eMat2(nbCol, nbCol);
  for (int iRow=0; iRow<nbCol; iRow++) {
    int iRow1=eSelect.ListRowSelect[iRow];
    int iRow2=OnPoints(iRow1, ePerm);
    eMat1.row(iRow)=EXT1.row(iRow1);
    eMat2.row(iRow)=EXT2.row(iRow2);
  }
  MyMatrix<T> eMat1inv=Inverse(eMat1);
  MyMatrix<T> RetMat=eMat1inv*eMat2;
  MyMatrix<T> CheckMat=EXT1*RetMat;
  for (int iRow1=0; iRow1<nbRow; iRow1++) {
    int iRow2=ePerm.at(iRow1);
    for (int iCol=0; iCol<nbCol; iCol++)
      if (CheckMat(iRow1,iCol) != EXT2(iRow2,iCol))
	return {false, {}};
  }
  return {true, RetMat};
}


template<typename T, typename Telt>
MyMatrix<T> FindTransformation(MyMatrix<T> const& EXT1, MyMatrix<T> const& EXT2, Telt const& ePerm)
{
  resultFT<T> eRes=FindTransformationGeneral(EXT1, EXT2, ePerm);
  assert(eRes.test);
  return eRes.eMat;
}


template<typename T, typename Tgroup>
bool IsSymmetryGroupOfPolytope(MyMatrix<T> const& EXT, Tgroup const& GRP)
{
  using Telt=typename Tgroup::Telt;
  MyMatrix<T> EXTred=ColumnReduction(EXT);
  std::vector<Telt> ListGen = GRP.GeneratorsOfGroup();
  for (auto const& eGen : ListGen) {
    resultFT<T> resFT=FindTransformationGeneral(EXTred, EXTred, eGen);
    if (!resFT.test)
      return false;
  }
  return true;
}




template<typename T>
struct MatrixGroup {
  int n;
  std::vector<MyMatrix<T>> ListGen;
};

// This is an internal type used for permutation representations
// of matrix groups.
// We hope that the right structures have already been implemented in permlib
// and that it is only a matter of template substritutions
template<typename T, typename Telt>
struct PairPermMat {
public:
  PairPermMat(PairPermMat const& p) = default;

  PairPermMat(Telt const& ePerm, MyMatrix<T> const& eMat) : perm(ePerm), mat(eMat) {}

  Telt GetPerm() const
  {
    return perm;
  }
  MyMatrix<T> GetMat() const
  {
    return mat;
  }
  PairPermMat operator*(PairPermMat const& p) const
  {
    Telt ePerm=perm*p.perm;
    MyMatrix<T> eMat=mat*p.mat;
    return PairPermMat(ePerm, eMat);
  }
  PairPermMat& operator*=(PairPermMat const& p)
  {
    Telt ePerm=perm*p.perm;
    MyMatrix<T> eMat=mat*p.mat;
    perm=ePerm;
    mat=eMat;
    return *this;
  }
  PairPermMat& operator^=(PairPermMat const& p)
  {
    Telt ePerm=p.perm*perm;
    MyMatrix<T> eMat=p.mat*mat;
    perm=ePerm;
    mat=eMat;
    return *this;
  }
  PairPermMat operator~() const
  {
    Telt ePerm=~perm;
    MyMatrix<T> eMat=Inverse(mat);
    return PairPermMat(ePerm, eMat);
  }
  bool operator==(PairPermMat const& p)
  {
    return p.mat==mat;
  }
  bool operator<(PairPermMat const &p) const
  {
    int n=mat.rows();
    for (int i=0; i<n; i++)
      for (int j=0; j<n; j++)
	if (mat(i,j) < p.mat(i,j))
	  return true;
    return false;
  }
  bool isIdentity() const
  {
    int n=mat.rows();
    for (int i=0; i<n; i++)
      for (int j=0; j<n; j++)
	if (i != j && mat(i,j) != 0)
	  return false;
    for (int j=0; j<n; j++)
      if (mat(j,j) != 1)
	  return false;
    return true;
  }
  int at(int const& val) const
  {
    return perm.at(val);
  }
  permlib::dom_int size() const
  {
    return perm.size();
  }
private:
  Telt perm;
  MyMatrix<T> mat;
};

// Compute Orbit of an object of type T2 under 
// a group generated by elements of type T1
template<typename T1, typename T2>
std::vector<T2> OrbitComputation(std::vector<T1> const& ListGen, T2 const& a, std::function<T2(T2 const&,T1 const&)> const& f)
{
  std::vector<int> ListStatus;
  std::vector<T2> TheOrbit;
  auto fInsert=[&](T2 const& u) -> void {
    int len=ListStatus.size();
    for (int i=0; i<len; i++)
      if (TheOrbit[i] == u)
	return;
    TheOrbit.push_back(u);
    ListStatus.push_back(0);
  };
  fInsert(a);
  while(true) {
    bool IsFinished=true;
    int len=ListStatus.size();
    for (int i=0; i<len; i++)
      if (ListStatus[i] == 0) {
	IsFinished=false;
	ListStatus[i]=1;
	for (auto & eGen : ListGen) {
	  T2 u=f(TheOrbit[i],eGen);
	  fInsert(u);
	}
      }
    if (IsFinished)
      break;
  }
  return TheOrbit;
}

template<typename T, typename Telt>
struct FiniteMatrixGroup {
  int n;
  MyMatrix<T> EXTfaithAct;
  std::vector<MyMatrix<T>> ListMatrGen;
  std::vector<Telt> ListPermGen;
};




// The space must be defining a finite index subgroup of T^n
template<typename T, typename Tgroup>
FiniteMatrixGroup<T,typename Tgroup::Telt> LinearSpace_ModStabilizer(FiniteMatrixGroup<T,typename Tgroup::Telt> const& GRPmatr, MyMatrix<T> const& TheSpace, T const& TheMod)
{
  using Telt = typename Tgroup::Telt;
  std::cerr << "TheMod=" << TheMod << "\n";
  int n=GRPmatr.n;
  std::cerr << "n=" << n << "\n";
  MyMatrix<T> ModSpace=TheMod*IdentityMat<T>(n);
  std::cerr << "TheSpace=\n";
  WriteMatrix(std::cerr, TheSpace);
  MyMatrix<T> TheSpaceMod=Concatenate(TheSpace, ModSpace);
  auto VectorMod=[&](MyVector<T> const& V) -> MyVector<T> {
    MyVector<T> Vret(n);
    for (int i=0; i<n; i++) {
      T q=QuoInt(V(i), TheMod);
      T nVal=V(i) - q*TheMod;
      //      std::cerr << "i=" << i << " V(i)=" << V(i) << " nVal=" << nVal << "\n";
      Vret(i)=nVal;
    }
    return Vret;
  };
  CanSolIntMat<T> eCan=ComputeCanonicalFormFastReduction(TheSpaceMod);
  std::function<MyVector<T>(MyVector<T> const&,MyMatrix<T> const&)> TheAction=[&](MyVector<T> const& eClass, MyMatrix<T> const& eElt) -> MyVector<T> {
    MyVector<T> eVect=ProductVectorMatrix(eClass, eElt);
    return VectorMod(eVect);
  };
  auto IsStabilizing=[&](MyVector<T> &V, FiniteMatrixGroup<T,Telt> const& TheGRP) -> bool {
    for (int i=0; i<n; i++) {
      MyVector<T> eVect=GetMatrixRow(TheSpace, i);
      std::cerr << "i=" << i << " |ListMatrGen|=" << TheGRP.ListMatrGen.size() << "\n";
      for (auto & eGen : TheGRP.ListMatrGen) {
	MyVector<T> eVectG=ProductVectorMatrix(eVect, eGen);
	ResultSolutionIntMat<T> eRes=SolutionIntMat(TheSpaceMod, eVectG);
	bool test=CanTestSolutionIntMat(eCan, eVectG);
	if (test != eRes.TheRes) {
	  std::cerr << "Inconsistency of result between two SolutionIntMat functions\n";
	  throw TerminalException{1};
	}
	if (!eRes.TheRes) {
	  V=VectorMod(eVect);
	  /*
	  std::cerr << "eVect=\n";
	  WriteVector(std::cerr, eVect);
	  std::cerr << "V=\n";
	  WriteVector(std::cerr, V);*/
	  return false;
	}
      }
    }
    return true;
  };
  FiniteMatrixGroup<T,Telt> GRPret=GRPmatr;
  std::vector<MyVector<T>> ListVect;
  int nbRow=GRPmatr.EXTfaithAct.rows();
  std::cerr << "|G(EXT)|=" << Tgroup(GRPmatr.ListPermGen, nbRow).size() << "\n";

  /*  for (int i=0; i<nbRow; i++) {
    MyVector<T> eLine=GetMatrixRow(GRPmatr.EXTfaithAct, i);
    ListVect.push_back(eLine);
    }*/
  while(true) {
    std::cerr << "Before definition of V\n";
    MyVector<T> V;
    std::cerr << "Before IsStabilizing test\n";
    bool test=IsStabilizing(V, GRPret);
    std::cerr << "test=" << test << "\n";
    if (test)
      break;
    std::cerr << "V=\n";
    WriteVector(std::cerr, V);
    std::vector<MyVector<T>> O=OrbitComputation(GRPret.ListMatrGen, V, TheAction);
    int Osiz=O.size();
    std::cerr << "Osiz=" << Osiz << "\n";
    int siz=nbRow + Osiz;
    //    std::vector<MyVector<T>> ListWork=ConcatenateVect(ListVect, O);
    //    int siz=ListWork.size();
    //    std::cerr << "siz=" << siz << "\n";
    Telt ePermS=SortingPerm<MyVector<T>,Telt>(O);
    Telt ePermSinv=~ePermS;
    /*    std::cerr << "We have ePermS\n";
    for (int i=0; i<Osiz; i++) {
      std::cerr << "i=" << i << "/" << siz << "\n";
      int j=ePermS.at(i);
      WriteVector(std::cerr, O[j]);
      }*/
    std::vector<permlib::Permutation> ListPermGenProv;
    int nbGen=GRPret.ListMatrGen.size();
    std::cerr << "nbGen=" << nbGen << "\n";
    for (int iGen=0; iGen<nbGen; iGen++) {
      MyMatrix<T> eMatrGen=GRPret.ListMatrGen[iGen];
      permlib::Permutation ePermGen=GRPret.ListPermGen[iGen];
      std::vector<permlib::dom_int> v(siz);
      //      std::cerr << "siz=" << siz << " nbRow=" << nbRow << "\n";
      for (int i=0; i<nbRow; i++) {
	//	std::cerr << "i=" << i << " / " << nbRow << "\n";
	int j=ePermGen.at(i);
	//	std::cerr << "j=" << j << "\n";
	v[i]=j;
	//	std::cerr << "After assignation\n";
      }
      std::cerr << "We have initialized the first part\n";
      std::vector<MyVector<T>> ListImage(Osiz);
      //      std::cerr << "|O|=" << O.size() << "\n";
      for (int iV=0; iV<Osiz; iV++) {
	//	std::cerr << "iV=" << iV << " / " << Osiz << "\n";
	MyVector<T> eV=O[iV];
	//	std::cerr << "We have eV\n";
	MyVector<T> fV=TheAction(eV, eMatrGen);
	//	std::cerr << "We have fV\n";
	ListImage[iV]=fV;
	//	std::cerr << "We have assigned ListImage\n";
      }
      std::cerr << "We have ListImage\n";
      Telt ePermB=SortingPerm<MyVector<T>,Telt>(ListImage);
      Telt ePermGenSelect=ePermB*ePermSinv;
      std::cerr << "We have ePermGenSelect\n";
      for (int iO=0; iO<Osiz; iO++) {
	int jO=ePermGenSelect.at(iO);
	v[nbRow+iO]=nbRow+jO;
      }
      permlib::Permutation eNewPerm(v);
      std::cerr << "We have eNewPerm\n";
      ListPermGenProv.push_back(eNewPerm);
    }
    Tgroup GRPwork(ListPermGenProv, siz);
    std::cerr << "|GRPwork|=" << GRPwork.size() << "\n";
    Face eFace(siz);
    for (int iO=0; iO<Osiz; iO++) {
      ResultSolutionIntMat<T> eRes=SolutionIntMat(TheSpaceMod, O[iO]);
      if (eRes.TheRes)
	eFace[nbRow + iO]=1;
    }
    Tgroup eStab=GRPwork.Stabilizer_OnSets(eFace);
    std::cerr << "|eStab|=" << eStab.size() << "\n";
    std::vector<MyMatrix<T>> ListMatrGen;
    std::vector<permlib::Permutation> ListPermGen;
    for (auto & eGen : eStab.group->S) {
      std::vector<permlib::dom_int> v(nbRow);
      for (int i=0; i<nbRow; i++)
	v[i]=eGen->at(i);
      permlib::Permutation ePerm(v);
      //      std::cerr << "Before call to FindTransformation (LinearSpace_ModStabilizer)\n";
      MyMatrix<T> eMatr=FindTransformation(GRPmatr.EXTfaithAct, GRPmatr.EXTfaithAct, ePerm);
      //      std::cerr << "After call to FindTransformation (LinearSpace_ModStabilizer)\n";
      ListPermGen.push_back(ePerm);
      ListMatrGen.push_back(eMatr);
    }
    std::cerr << "All generators have been created\n";
    GRPret={n, GRPmatr.EXTfaithAct, ListMatrGen, ListPermGen};
    std::cerr << "GRPret has been created\n";
  }
  return GRPret;
}


template<typename T>
T LinearSpace_GetDivisor(MyMatrix<T> const& TheSpace)
{
  T TheDet=T_abs(DeterminantMat(TheSpace));
  T eDiv=1;
  int n=TheSpace.rows();
  while(true) {
    bool IsOK=true;
    for (int i=0; i<n; i++)
      if (IsOK) {
	MyVector<T> eVect=ZeroVector<T>(n);
	eVect(i)=eDiv;
	bool test=SolutionIntMat(TheSpace, eVect).TheRes;
	if (!test)
	  IsOK=false;
      }
    if (IsOK)
      return eDiv;
    if (eDiv > TheDet) {
      std::cerr << "Clear error in LinearSpace_GetDivisor\n";
      throw TerminalException{1};
    }
    eDiv += 1;
  }
}



template<typename T, typename Telt>
FiniteMatrixGroup<T,Telt> LinearSpace_Stabilizer(FiniteMatrixGroup<T,Telt> const& GRPmatr, MyMatrix<T> const& TheSpace)
{
  int n=GRPmatr.n;
  std::cerr << "TheSpace=\n";
  WriteMatrixGAP(std::cerr, TheSpace);
  std::cerr << "det(TheSpace)=" << DeterminantMat(TheSpace) << "\n";
  auto IsStabilizing=[&](FiniteMatrixGroup<T,Telt> const& TheGRP) -> bool {
    std::cerr << "Begin IsStabilizing test\n";
    for (int i=0; i<n; i++) {
      MyVector<T> eVect=GetMatrixRow(TheSpace, i);
      for (auto & eGen : TheGRP.ListMatrGen) {
	MyVector<T> eVectG=ProductVectorMatrix(eVect, eGen);
	ResultSolutionIntMat<T> eRes=SolutionIntMat(TheSpace, eVectG);
	if (!eRes.TheRes) {
	  std::cerr << "Leaving IsStabilzing: false\n";
	  return false;
	}
      }
    }
    std::cerr << "Leaving IsStabilzing: true\n";
    return true;
  };
  if (IsStabilizing(GRPmatr))
    return GRPmatr;
  T LFact=LinearSpace_GetDivisor(TheSpace);
  std::cerr << "LFact=" << LFact << "\n";
  std::vector<T> eList=FactorsInt(LFact);
  int siz=eList.size();
  std::cerr << "siz=" << siz << "\n";
  FiniteMatrixGroup<T,Telt> GRPret=GRPmatr;
  for (int i=1; i<=siz; i++) {
    T TheMod=1;
    for (int j=0; j<i; j++)
      TheMod *= eList[j];
    std::cerr << "TheMod=" << TheMod << "\n";
    GRPret=LinearSpace_ModStabilizer(GRPret, TheSpace, TheMod);
    if (IsStabilizing(GRPret))
      return GRPret;
  }
  if (!IsStabilizing(GRPret)) {
    std::cerr << "Error in LinearSpace_Stabilizer\n";
    throw TerminalException{1};
  }
  return GRPret;
}

template<typename T, typename Telt>
struct ResultTestModEquivalence {
  bool TheRes;
  FiniteMatrixGroup<T,Telt> GRPwork;
  MyMatrix<T> eEquiv;
};



template<typename T, typename Tgroup>
ResultTestModEquivalence<T, typename Tgroup::Telt> LinearSpace_ModEquivalence(FiniteMatrixGroup<T, typename Tgroup::Telt> const& GRPmatr, MyMatrix<T> const& TheSpace1, MyMatrix<T> const& TheSpace2, T const& TheMod)
{
  using Telt = typename Tgroup::Telt;
  int n=TheSpace1.rows();
  MyMatrix<T> ModSpace=TheMod*IdentityMat<T>(n);
  MyMatrix<T> TheSpace1Mod=Concatenate(TheSpace1, ModSpace);
  MyMatrix<T> TheSpace2Mod=Concatenate(TheSpace2, ModSpace);
  auto VectorMod=[&](MyVector<T> const& V) -> MyVector<T> {
    MyVector<T> Vret(n);
    for (int i=0; i<n; i++) {
      T q=QuoInt(V(i), TheMod);
      T nVal=V(i) - q*TheMod;
      Vret(i)=nVal;
    }
    return Vret;
  };
  std::function<MyVector<T>(MyVector<T> const&,MyMatrix<T> const&)> TheAction=[&](MyVector<T> const& eClass, MyMatrix<T> const& eElt) -> MyVector<T> {
    MyVector<T> eVect=ProductVectorMatrix(eClass, eElt);
    return VectorMod(eVect);
  };
  std::function<bool(MyVector<T>&, MyMatrix<T> const&)> IsEquiv=[&](MyVector<T> & V, MyMatrix<T> const& eEquiv) -> bool {
    for (int i=0; i<n; i++) {
      MyVector<T> eVect=GetMatrixRow(TheSpace1, i);
      MyVector<T> eVectG=ProductVectorMatrix(eVect, eEquiv);
      ResultSolutionIntMat<T> eRes=SolutionIntMat(TheSpace2Mod, eVectG);
      if (!eRes.TheRes) {
	V=VectorMod(eVect);
	return false;
      }
    }
    return true;    
  };
  FiniteMatrixGroup<T,Telt> GRPwork=GRPmatr;
  MyMatrix<T> eElt=IdentityMat<T>(n);
  int nbRow=GRPmatr.EXTfaithAct.rows();
  /*  std::vector<MyVector<T>> ListVect;
  for (int i=0; i<nbRow; i++) {
    MyVector<T> eLine=GetMatrixRow(GRPmatr.EXTfaithAct, i);
    ListVect.push_back(eLine);
    }*/
  while(true) {
    MyVector<T> V;
    bool test=IsEquiv(V, eElt);
    if (test)
      return {true, GRPwork, eElt};
    std::vector<MyVector<T>> O=OrbitComputation(GRPwork.ListMatrGen, V, TheAction);
    int Osiz=O.size();
    //    std::vector<MyVector<T>> ListWork=ConcatenateVect(ListVect, O);
    int siz=nbRow + Osiz;
    permlib::Permutation ePermS=SortingPerm(O);
    permlib::Permutation ePermSinv=~ePermS;
    std::vector<permlib::Permutation> ListPermGenProv;
    int nbGen=GRPwork.ListMatrGen.size();
    std::cerr << "nbGen=" << nbGen << "\n";
    for (int iGen=0; iGen<nbGen; iGen++) {
      MyMatrix<T> eMatrGen=GRPwork.ListMatrGen[iGen];
      permlib::Permutation ePermGen=GRPwork.ListPermGen[iGen];
      std::vector<permlib::dom_int> v(siz);
      for (int i=0; i<nbRow; i++) {
	int j=ePermGen.at(i);
	v[i]=j;
      }
      std::vector<MyVector<T>> ListImage;
      for (auto & eV : O)
	ListImage.push_back(TheAction(eV, eMatrGen));
      Telt ePermB=SortingPerm<MyVector<T>,Telt>(ListImage);
      Telt ePermGenSelect=ePermB*ePermSinv;
      for (int iO=0; iO<Osiz; iO++) {
	int jO=ePermGenSelect.at(iO);
	v[nbRow+iO]=nbRow+jO;
      }
      permlib::Permutation eNewPerm(v);
      ListPermGenProv.push_back(eNewPerm);
    }
    Tgroup GRPperm(ListPermGenProv, siz);
    MyMatrix<T> TheSpace1work=TheSpace1*eElt;
    Face eFace1(siz);
    Face eFace2(siz);
    for (int iO=0; iO<Osiz; iO++) {
      MyVector<T> eVect=O[iO];
      ResultSolutionIntMat<T> eRes1=SolutionIntMat(TheSpace1work, eVect);
      if (eRes1.TheRes)
	eFace1[nbRow + iO]=1;
      ResultSolutionIntMat<T> eRes2=SolutionIntMat(TheSpace2Mod, eVect);
      if (eRes2.TheRes)
	eFace2[nbRow + iO]=1;
    }
    std::pair<bool,Telt> eRes=GRPperm.RepresentativeAction_OnSets(eFace1, eFace2);
    if (!eRes.first)
      return {false, {}, {}};
    Tgroup eStab=GRPperm.Stabilizers_OnSets(eFace2);
    std::vector<MyMatrix<T>> ListMatrGen;
    std::vector<Telt> ListPermGen;
    std::vector<Telt> LGen = eStab.GeneratorsOfGroup();
    for (auto & eGen : LGen) {
      std::vector<int> v(nbRow);
      for (int i=0; i<nbRow; i++)
	v[i]=eGen->at(i);
      Telt ePerm(v);
      MyMatrix<T> eMatr=FindTransformation(GRPmatr.EXTfaithAct, GRPmatr.EXTfaithAct, ePerm);
      ListPermGen.push_back(ePerm);
      ListMatrGen.push_back(eMatr);
    }
    GRPwork={n, GRPmatr.EXTfaithAct, ListMatrGen, ListPermGen};
    //
    MyMatrix<T> eMat=FindTransformation(GRPmatr.EXTfaithAct, GRPmatr.EXTfaithAct, eRes.TheEquiv);
    eElt=eElt*eMat;
  }
  for (auto & eGen : GRPwork.ListMatrGen) {
    MyVector<T> V;
    bool test=IsEquiv(V, eGen);
    if (!test) {
      std::cerr << "We have a major inconsistency in LinearSpace_ModEquivalence\n";
      throw TerminalException{1};
    }
  }
  return {true, GRPwork, eElt};
}



template<typename T, typename Telt>
EquivTest<MyMatrix<T>> LinearSpace_Equivalence(FiniteMatrixGroup<T,Telt> const& GRPmatr, MyMatrix<T> const& TheSpace1, MyMatrix<T> const& TheSpace2)
{
  int n=TheSpace1.rows();
  T LFact1=LinearSpace_GetDivisor(TheSpace1);
  T LFact2=LinearSpace_GetDivisor(TheSpace2);
  if (LFact1 != LFact2)
    return {false, {}};
  std::vector<T> eList=FactorsInt(LFact1);
  auto IsEquivalence=[&](MyMatrix<T> const& eEquiv) -> bool {
    for (int i=0; i<n; i++) {
      MyVector<T> eVect=GetMatrixRow(TheSpace1, i);
      MyVector<T> eVectG=ProductVectorMatrix(eVect, eEquiv);
      ResultSolutionIntMat<T> eRes=SolutionIntMat(TheSpace2, eVectG);
      if (!eRes.TheRes)
	return false;
    }
    return true;
  };
  FiniteMatrixGroup<T,Telt> GRPwork=GRPmatr;
  int siz=eList.size();
  FiniteMatrixGroup<T,Telt> GRPret=GRPmatr;
  MyMatrix<T> eElt=IdentityMat<T>(n);
  for (int i=1; i<=siz; i++) {
    if (IsEquivalence(eElt))
      return {true, eElt};
    T TheMod=1;
    for (int j=0; j<i; j++)
      TheMod *= eList[j];
    MyMatrix<T> TheSpace1Img=TheSpace1*eElt;
    ResultTestModEquivalence<T,Telt> eRes=LinearSpace_ModEquivalence(GRPwork, TheSpace1Img, TheSpace2, TheMod);
    if (!eRes.TheRes)
      return {false, {}};
    eElt=eElt*eRes.eEquiv;
    GRPwork=eRes.GRPwork;
  }
  if (!IsEquivalence(eElt)) {
    std::cerr << "Error in LinearSpace_Equivalence\n";
    throw TerminalException{1};
  }
  return {true, eElt};
}


template<typename T,typename Telt>
FiniteMatrixGroup<T,Telt> LinPolytopeIntegral_Automorphism_Subspaces(FiniteMatrixGroup<T,Telt> const& GRP)
{
  int dim=GRP.EXTfaithAct.cols();
  //  std::cerr << "GRP.EXTfaithAct(rows/cols)=" << GRP.EXTfaithAct.rows() << " / " << GRP.EXTfaithAct.cols() << "\n";
  MyMatrix<T> eBasis=GetZbasis(GRP.EXTfaithAct);
  //  std::cerr << "We have eBasis\n";
  //  WriteMatrixGAP(std::cerr, eBasis);
  //  std::cerr << "We have EXTfaithAct\n";
  //  WriteMatrixGAP(std::cerr, GRP.EXTfaithAct);
  MyMatrix<T> EXTbas=GRP.EXTfaithAct*Inverse(eBasis);
  //  std::cerr << "EXTbas=\n";
  //  WriteMatrixGAP(std::cerr, EXTbas);
  std::vector<MyMatrix<T>> ListMatrGen;
  for (auto & eGen : GRP.ListPermGen) {
    MyMatrix<T> TheMat=FindTransformation(EXTbas, EXTbas, eGen);
    /*    std::cerr << "TheMat=\n";
	  WriteMatrixGAP(std::cerr, TheMat);*/
    ListMatrGen.push_back(TheMat);
  }
  FiniteMatrixGroup<T,Telt> GRPmatr{dim, EXTbas, ListMatrGen, GRP.ListPermGen};
  MyMatrix<T> LattToStab=RemoveFractionMatrix(Inverse(eBasis));
  FiniteMatrixGroup<T,Telt> eStab=LinearSpace_Stabilizer(GRPmatr, LattToStab);
  //  std::cerr << "After LinearSpace_Stabilizer\n";
  std::vector<MyMatrix<T>> ListMatrGensB;
  for (auto & eGen : eStab.ListPermGen) {
    MyMatrix<T> TheMat=FindTransformation(GRP.EXTfaithAct, GRP.EXTfaithAct, eGen);
    if (!IsIntegralMatrix(TheMat)) {
      std::cerr << "Clear error in the code\n";
      throw TerminalException{1};
    }
    ListMatrGensB.push_back(TheMat);
  }
  //  std::cerr << "Before leaving LinPolytopeIntegral_Automorphism_Subspaces\n";
  return {dim, GRP.EXTfaithAct, ListMatrGensB, eStab.ListPermGen};
}


template<typename T, typename Tgroup>
EquivTest<MyMatrix<T>> LinPolytopeIntegral_Isomorphism_Method8(MyMatrix<T> const& EXT1_T, MyMatrix<T> const& EXT2_T, Tgroup const& GRP1, typename Tgroup::Telt const& ePerm)
{
  using Telt = typename Tgroup::Telt;
  std::vector<Telt> ListPermGens;
  std::vector<MyMatrix<T>> ListMatrGens;
  int n=EXT2_T.cols();
  std::vector<Telt> LGen = GRP1.GeneratorsOfGroup();
  for (auto & eGen : LGen) {
    permlib::Permutation ePermGen=(~ePerm) * eGen * ePerm;
    ListPermGens.push_back(ePermGen);
    MyMatrix<T> eMatr=FindTransformation(EXT2_T, EXT2_T, ePermGen);
    ListMatrGens.push_back(eMatr);
  }
  FiniteMatrixGroup<T,Telt> GRP2{n, EXT2_T, ListMatrGens, ListPermGens};
  return LinPolytopeIntegral_Isomorphism_Subspaces(EXT1_T, EXT2_T, GRP2, ePerm);
}


template<typename T, typename Tgroup>
EquivTest<MyMatrix<T>> LinPolytopeIntegral_Isomorphism_Method4(MyMatrix<T> const& EXT1_T, MyMatrix<T> const& EXT2_T, Tgroup const& GRP1, typename Tgroup::Telt const& ePerm, std::function<bool(MyMatrix<T>)> const& IsMatrixCorrect)
{
  using Telt=typename Tgroup::Telt;
  IteratorGrp eIter=GetInitialIterator(GRP1);
  while(true) {
    Telt fPerm=GetPermutation(eIter);
    Telt eEquivCand=fPerm*ePerm;
    MyMatrix<T> eBigMat=FindTransformation(EXT1_T, EXT2_T, eEquivCand);
    if (IsMatrixCorrect(eBigMat))
      return {true, eBigMat};
    int res=IteratorIncrease(eIter);
    if (res == -1)
      break;
  }
  return {false, {}};
}

template<typename T, typename Tgroup>
Tgroup LinPolytopeIntegral_Stabilizer_Method4(MyMatrix<T> const& EXT_T, Tgroup const& GRPisom, std::function<bool(MyMatrix<T>)> const& IsMatrixCorrect)
{
  int nbVert=EXT_T.rows();
  std::vector<permlib::Permutation> generatorList;
  Tgroup GRPret(nbVert);
  IteratorGrp eIterRet;
  auto fConstruct=[&]() -> void {
    GRPret = Tgroup(generatorList, nbVert);
    eIterRet=GetInitialIterator(GRPret);
  };
  fConstruct();
  auto fInsert=[&](permlib::Permutation const& ePerm) -> void {
    bool test=TestBelongingInGroup(eIterRet, ePerm);
    if (!test) {
      generatorList.push_back(ePerm);
      fConstruct();
    }
  };
  IteratorGrp eIter=GetInitialIterator(GRPisom);
  while(true) {
    permlib::Permutation ePerm=GetPermutation(eIter);
    MyMatrix<T> eBigMat=FindTransformation(EXT_T, EXT_T, ePerm);
    if (IsMatrixCorrect(eBigMat))
      fInsert(ePerm);
    int res=IteratorIncrease(eIter);
    if (res == -1)
      break;
  }
  return GRPret;
}

template<typename T, typename Tgroup>
Tgroup LinPolytopeIntegral_Stabilizer_Method8(MyMatrix<T> const& EXT_T, Tgroup const& GRPisom)
{
  using Telt=typename Tgroup::Telt;
  int nbVert=EXT_T.rows();
  int dim=EXT_T.cols();
  std::vector<Telt> ListPermGen;
  std::vector<MyMatrix<T>> ListMatrGen;
  std::vector<Telt> LGen = GRPisom.GeneratorsOfGroup();
  for (auto & eGen : LGen) {
    MyMatrix<T> eMat=FindTransformation(EXT_T, EXT_T, eGen);
    ListMatrGen.push_back(eMat);
    ListPermGen.push_back(eGen);
  }
  FiniteMatrixGroup<T,Telt> GRPfin{dim, EXT_T, ListMatrGen, ListPermGen};
  FiniteMatrixGroup<T,Telt> GRPfinal=LinPolytopeIntegral_Automorphism_Subspaces(GRPfin);
  return Tgroup(GRPfinal.ListPermGen, nbVert);
}




template<typename T,typename Telt>
EquivTest<MyMatrix<T>> LinPolytopeIntegral_Isomorphism_Subspaces(MyMatrix<T> const& EXT1_T, MyMatrix<T> const& EXT2_T, FiniteMatrixGroup<T,Telt> const& GRP2, Telt const& eEquiv)
{
  int dim=EXT1_T.cols();
  MyMatrix<T> eBasis1=GetZbasis(EXT1_T);
  MyMatrix<T> eBasis2=GetZbasis(EXT2_T);
  MyMatrix<T> EXTbas1=EXT1_T*Inverse(eBasis1);
  MyMatrix<T> EXTbas2=EXT2_T*Inverse(eBasis2);

  MyMatrix<T> TheMatEquiv=FindTransformation(EXTbas1, EXTbas2, eEquiv);
  std::vector<MyMatrix<T>> ListMatrGen;
  for (auto & eGen : GRP2.ListPermGen) {
    MyMatrix<T> TheMat=FindTransformation(EXTbas2, EXTbas2, eGen);
    ListMatrGen.push_back(TheMat);
  }
  FiniteMatrixGroup<T,Telt> GRPspace{dim, EXTbas2, ListMatrGen, GRP2.ListPermGen};
  MyMatrix<T> eLatt1=Inverse(eBasis1)*TheMatEquiv;
  MyMatrix<T> eLatt2=Inverse(eBasis2);
  FractionMatrix<T> eRec1=RemoveFractionMatrixPlusCoeff(eLatt1);
  FractionMatrix<T> eRec2=RemoveFractionMatrixPlusCoeff(eLatt2);
  if (eRec1.TheMult != eRec2.TheMult)
    return {false, {}};
  EquivTest<MyMatrix<T>> eSpaceEquiv=LinearSpace_Equivalence(GRPspace, eRec1.TheMat, eRec2.TheMat);
  if (!eSpaceEquiv.TheReply)
    return {false, {}};
  MyMatrix<T> eMatFinal=Inverse(eBasis1)*TheMatEquiv*eSpaceEquiv.TheEquiv*eBasis2;
  if (!IsIntegralMatrix(eMatFinal)) {
    std::cerr << "eMatFinal should be integral\n";
    throw TerminalException{1};
  }
  return {true, eMatFinal};
}






#endif
