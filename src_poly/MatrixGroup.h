#ifndef SRC_POLY_MATRIXGROUP_H_
#define SRC_POLY_MATRIXGROUP_H_

#include "GRP_GroupFct.h"
#include "Group.h"
#include "MAT_MatrixInt.h"
#include "MatrixGroupBasic.h"
#include "PERM_Fct.h"
#include "factorizations.h"
#include "Timings.h"
#include <limits>
#include <utility>
#include <vector>
#include <unordered_map>

template <typename T> struct MatrixGroup {
  int n;
  std::vector<MyMatrix<T>> ListGen;
};

template <typename T> bool IsIdentity(MyMatrix<T> const &M) {
  int len = M.rows();
  for (int i = 0; i < len; i++) {
    for (int j = 0; j < len; j++) {
      if (i == j && M(i, j) != 1)
        return false;
      if (i != j && M(i, j) != 0)
        return false;
    }
  }
  return true;
}

template <typename T> T LinearSpace_GetDivisor(MyMatrix<T> const &TheSpace) {
  T TheDet = T_abs(DeterminantMat(TheSpace));
  T eDiv = 1;
  int n = TheSpace.rows();
  CanSolIntMat<T> eCan = ComputeCanonicalFormFastReduction(TheSpace);
  while (true) {
    bool IsOK = true;
    for (int i = 0; i < n; i++)
      if (IsOK) {
        MyVector<T> eVect = ZeroVector<T>(n);
        eVect(i) = eDiv;
        bool test = CanTestSolutionIntMat(eCan, eVect);
        if (!test)
          IsOK = false;
      }
    if (IsOK)
      return eDiv;
    if (eDiv > TheDet) {
      std::cerr << "eDiv=" << eDiv << " TheDet=" << TheDet << "\n";
      std::cerr << "TheSpace=\n";
      WriteMatrix(std::cerr, TheSpace);
      std::cerr << "Clear error in LinearSpace_GetDivisor\n";
      throw TerminalException{1};
    }
    eDiv += 1;
  }
}

template <typename T>
MyMatrix<T>
MatrixIntegral_GetInvariantSpace(int const &n,
                                 std::vector<MyMatrix<T>> const &LGen) {
  std::vector<MyMatrix<T>> LGenTot;
  for (auto &eGen : LGen) {
    LGenTot.push_back(eGen);
    LGenTot.push_back(Inverse(eGen));
  }
  LGenTot.push_back(IdentityMat<T>(n));
  MyMatrix<T> TheSpace = IdentityMat<T>(n);
  T TheDet = 1;
  while (true) {
    std::vector<MyVector<T>> ConcatSpace;
    for (auto &eGen : LGenTot) {
      MyMatrix<T> TheSpaceImg = TheSpace * eGen;
      for (int i = 0; i < n; i++)
        ConcatSpace.push_back(GetMatrixRow(TheSpaceImg, i));
    }
    MyMatrix<T> NewSpace = GetZbasis(MatrixFromVectorFamily(ConcatSpace));
    T NewDet = T_abs(DeterminantMat(NewSpace));
    if (NewDet == TheDet)
      return TheSpace;
    TheSpace = NewSpace;
    TheDet = NewDet;
  }
}






// Compute Orbit of an object of type T2 under
// a group generated by elements of type T1
template <typename T1, typename T2, typename Fprod, typename Fterminate>
std::optional<std::vector<T2>> OrbitComputation_limit(std::vector<T1> const &ListGen, T2 const &a,
                                       const Fprod &f_prod, const Fterminate & f_terminate) {
#ifdef DEBUG_MATRIX_GROUP
  std::cerr << "Begin of OrbitComputation_limit\n";
#endif
  std::vector<T2> TheOrbit;
  std::unordered_map<T2,uint8_t> map;
  auto fInsert = [&](T2 const &u) -> bool {
    uint8_t & pos = map[u];
    if (pos == 0) {
      pos = 1;
      TheOrbit.push_back(u);
      return f_terminate(u);
    }
    return false;
  };
  if (fInsert(a))
    return {};
  size_t pos = 0;
  while (true) {
    size_t len = TheOrbit.size();
    if (pos == len)
      break;
    for (size_t i = pos; i < len; i++)
      for (auto &eGen : ListGen) {
        T2 u = f_prod(TheOrbit[i], eGen);
        if (fInsert(u))
          return {};
      }
    pos = len;
  }
#ifdef DEBUG_MATRIX_GROUP
  std::cerr << "End of OrbitComputation_limit\n";
#endif
  return TheOrbit;
}


template <typename T1, typename T2, typename Fprod>
std::vector<T2> OrbitComputation(std::vector<T1> const &ListGen, T2 const &a,
                                 const Fprod &f_prod) {
  auto f_terminate=[&]([[maybe_unused]] T2 const& a) -> bool {
    return false;
  };
  std::optional<std::vector<T2>> opt = OrbitComputation_limit(ListGen, a, f_prod, f_terminate);
  if (!opt) {
    std::cerr << "The opt should have been assigned\n";
    throw TerminalException{1};
  }
  return *opt;
}

/*
We want to find the vectors x in Z^n such that
x TheSpace P = x TheSpace + u MOD
 */
template <typename T>
MyMatrix<T> ComputeBasisInvariantSpace(std::vector<MyMatrix<T>> const& ListMat, MyMatrix<T> const& TheSpace, T const& eMod)
{
  int n = TheSpace.rows();
  int n_mat = ListMat.size();
  MyMatrix<T> Equa(2 * n, n_mat * n);
  for (int i_mat=0; i_mat<n_mat; i_mat++) {
    MyMatrix<T> const& eMat = ListMat[i_mat];
    MyMatrix<T> eProd = TheSpace * eMat - TheSpace;
    for (int i=0; i<n; i++) {
      for (int j=0; j<n; j++) {
        Equa(i,j + i_mat * n) = eProd(i,j);
        if (i == j) {
          Equa(i + n, j + i_mat * n) = eMod;
        } else {
          Equa(i + n, j + i_mat * n) = 0;
        }
      }
    }
  }
  MyMatrix<T> NSP = SolutionIntMat(Equa);
  int n_row = NSP.rows();
  MyMatrix<T> NSP_red(n,n);
  for (int i=0; i<n_row; i++)
    for (int j=0; j<n; j++)
      NSP_red(i,j) = NSP(i,j);
  return NSP_red * TheSpace;
}


template <typename T, typename Tmod>
MyMatrix<Tmod> ModuloReductionMatrix(MyMatrix<T> const &M, T const &TheMod) {
  int n_row = M.rows();
  int n_col = M.cols();
  MyMatrix<Tmod> RetMat(n_row, n_col);
  for (int i = 0; i < n_row; i++) {
    for (int j = 0; j < n_col; j++) {
      T val = ResInt(M(i, j), TheMod);
      RetMat(i, j) = UniversalScalarConversion<Tmod, T>(val);
    }
  }
  return RetMat;
}

template <typename T, typename Tmod>
std::vector<MyMatrix<Tmod>>
ModuloReductionStdVectorMatrix(std::vector<MyMatrix<T>> const &ListM,
                               T const &TheMod) {
  std::vector<MyMatrix<Tmod>> ListRetMat;
  for (auto &M : ListM)
    ListRetMat.push_back(ModuloReductionMatrix<T, Tmod>(M, TheMod));
  return ListRetMat;
}

template <typename T, typename Tmod>
MyVector<Tmod> ModuloReductionVector(MyVector<T> const &V, T const &TheMod) {
  int siz = V.size();
  MyVector<Tmod> retV(siz);
  for (int i = 0; i < siz; i++) {
    T val = ResInt(V(i), TheMod);
    retV(i) = UniversalScalarConversion<Tmod, T>(val);
  }
  return retV;
}



template<typename T, typename Tmod, typename Tgroup, typename Thelper>
std::vector<MyVector<Tmod>> FindingSmallOrbit(std::vector<MyMatrix<T>> const& ListMatrGen,
                                           MyMatrix<T> const& TheSpace, T const& TheMod, MyVector<Tmod> const& a,
                                           Thelper const& helper) {
  using Telt = typename Tgroup::Telt;
  int n = TheSpace.rows();
  size_t n_limit = 30000; // The critical number for the computation
  size_t pos = 0;
  auto f_terminate=[&]([[maybe_unused]] MyVector<Tmod> const& a) -> bool {
    pos++;
    if (pos == n_limit)
      return true;
    return false;
  };
  MyMatrix<T> ModSpace = TheMod * IdentityMat<T>(n);
  MyMatrix<T> TheSpaceMod = Concatenate(TheSpace, ModSpace);
  CanSolIntMat<T> eCan = ComputeCanonicalFormFastReduction(TheSpaceMod);
  Tmod TheMod_mod = UniversalScalarConversion<Tmod, T>(TheMod);
  std::vector<MyMatrix<Tmod>> ListMatrGenMod =
    ModuloReductionStdVectorMatrix<T, Tmod>(ListMatrGen, TheMod);
  auto f_prod = [&](MyVector<Tmod> const &eClass, MyMatrix<Tmod> const &eElt) -> MyVector<Tmod> {
    MyVector<Tmod> eVect = eElt.transpose() * eClass;
    return VectorMod(eVect, TheMod_mod);
  };


  std::optional<std::vector<MyVector<Tmod>>> opt = OrbitComputation_limit(ListMatrGenMod, a, f_prod, f_terminate);
  if (opt) {
    return *opt;
  }
  std::vector<Telt> ListPermGen;
  for (auto & eMatrGen : ListMatrGen) {
    Telt ePermGen = GetPermutationForFiniteMatrixGroup(helper, eMatrGen);
    ListPermGen.push_back(ePermGen);
  }
  size_t len = helper.EXTfaithful.rows();
  Telt id_perm(len);
  Tgroup GRP(ListPermGen, id_perm);
  std::vector<Tgroup> ListGroup = GRP.GetAscendingChain();
  size_t len_group = ListGroup.size();
  for (size_t iGroup=0; iGroup<len_group; iGroup++) {
    size_t jGroup = len_group - 1 - iGroup;
    Tgroup fGRP = ListGroup[jGroup];
    std::vector<MyMatrix<T>> LMatr;
    for (auto & eGen : fGRP.GeneratorsOfGroup()) {
      MyMatrix<T> eMat = RepresentPermutationAsMatrix(helper, eGen);
      LMatr.push_back(eMat);
    }
    MyMatrix<T> InvBasis = ComputeBasisInvariantSpace(LMatr, TheSpace, TheMod);
    
  }
  
}




//

template <typename T, typename Telt>
struct ResultGeneratePermutationGroup_Finite {
  int nbRow;
  int siz;
  std::vector<Telt> ListPermGens;
};

template <typename T, typename Telt> struct FiniteMatrixGroupHelper {
  using Treturn = ResultGeneratePermutationGroup_Finite<T, Telt>;
  int n;
  MyMatrix<T> EXTfaithful;
  std::vector<MyVector<T>> ListV;
  std::unordered_map<MyVector<T>, int> MapV;
};

//

template <typename T, typename Telt>
struct ResultGeneratePermutationGroup_FiniteIsotropic {
  int nbRow;
  int siz;
  std::vector<Telt> ListPermGens;
};

template <typename T, typename Telt> struct FiniteIsotropicMatrixGroupHelper {
  using Treturn = ResultGeneratePermutationGroup_FiniteIsotropic<T, Telt>;
  int n;
  MyMatrix<T> G;
  MyMatrix<T> EXTfaithful;
  std::vector<MyVector<T>> ListV;
  std::unordered_map<MyVector<T>, int> MapV;
};

//

template <typename T, typename Telt>
struct ResultGeneratePermutationGroup_General {
  int nbRow;
  int siz;
  std::vector<MyMatrix<T>> ListMatrGens;
  std::vector<Telt> ListPermGens;
};

template <typename T, typename Telt> struct GeneralMatrixGroupHelper {
  using Treturn = ResultGeneratePermutationGroup_General<T, Telt>;
  int n;
};

//

template <typename Thelper> struct has_determining_ext {
  static const bool value = false;
};

template <typename T, typename Telt>
struct has_determining_ext<FiniteMatrixGroupHelper<T, Telt>> {
  static const bool value = true;
};

template <typename T, typename Telt>
struct has_determining_ext<FiniteIsotropicMatrixGroupHelper<T, Telt>> {
  static const bool value = true;
};

//

template <typename T, typename Telt>
FiniteMatrixGroupHelper<T, Telt>
ComputeFiniteMatrixGroupHelper(MyMatrix<T> const &EXT) {
  std::vector<MyVector<T>> ListV;
  std::unordered_map<MyVector<T>, int> MapV;
  for (int i = 0; i < EXT.rows(); i++) {
    MyVector<T> V = GetMatrixRow(EXT, i);
    ListV.push_back(V);
    MapV[V] = i;
  }
  return {int(EXT.cols()), EXT, std::move(ListV), std::move(MapV)};
}

template <typename T, typename Telt>
FiniteIsotropicMatrixGroupHelper<T, Telt>
ComputeFiniteIsotropicMatrixGroupHelper(MyMatrix<T> const &G,
                                        MyMatrix<T> const &EXT) {
  std::vector<MyVector<T>> ListV;
  std::unordered_map<MyVector<T>, int> MapV;
  for (int i = 0; i < EXT.rows(); i++) {
    MyVector<T> V = GetMatrixRow(EXT, i);
    ListV.push_back(V);
    MapV[V] = i;
  }
  return {int(EXT.cols()), G, EXT, std::move(ListV), std::move(MapV)};
}

template <typename T, typename Telt, typename Thelper>
inline typename std::enable_if<has_determining_ext<Thelper>::value, Telt>::type
GetPermutationForFiniteMatrixGroup(Thelper const &helper,
                                   MyMatrix<T> const &eMatr) {
#ifdef DEBUG_MATRIX_GROUP
  //  std::cerr << "Beginning of GetPermutationForFiniteMatrixGroup\n";
  //  std::cerr << "|ListV|=" << helper.ListV.size() << "\n";
  //  for (auto & eV : helper.ListV)
  //    std::cerr << "V=" << StringVectorGAP(eV) << "\n";
  //  std::cerr << "eMat=" << StringMatrixGAP(eMatr) << "\n";
  //  MyMatrix<T> eProd = eMatr * helper.G * eMatr.transpose();
  //  std::cerr << "eProd=" << StringMatrixGAP(eProd) << "\n";
#endif
  using Tidx = typename Telt::Tidx;
  Tidx len = helper.EXTfaithful.rows();
  std::vector<Tidx> V(len);
  for (Tidx i = 0; i < len; i++) {
    MyVector<T> Vimg = eMatr.transpose() * helper.ListV[i];
#ifdef DEBUG_MATRIX_GROUP
    //    std::cerr << "i=" << i << " Vimg=" << StringVectorGAP(Vimg) << "\n";
#endif
    V[i] = helper.MapV.at(Vimg);
  }
#ifdef DEBUG_MATRIX_GROUP
  //  std::cerr << "Beginning of GetPermutationForFiniteMatrixGroup\n";
#endif
  return Telt(std::move(V));
}






template <typename T, typename Tmod>
Face GetFace(int const &nbRow, std::vector<MyVector<Tmod>> const &O,
             MyMatrix<T> const &TheSpace) {
  size_t Osiz = O.size();
  size_t siz = nbRow + Osiz;
  //  std::cerr << "GetFace : nbRow=" << nbRow << "\n";
  Face eFace(siz);
  CanSolIntMat<T> eCan = ComputeCanonicalFormFastReduction(TheSpace);
  for (size_t iO = 0; iO < Osiz; iO++) {
    MyVector<T> const &eVect = UniversalVectorConversion<T, Tmod>(O[iO]);
    bool test = CanTestSolutionIntMat(eCan, eVect);
    if (test) {
      eFace[nbRow + iO] = 1;
    }
  }
  return eFace;
}

template <typename T>
MyVector<T> VectorMod(MyVector<T> const &V, T const &TheMod) {
  int n = V.size();
  MyVector<T> Vret(n);
  for (int i = 0; i < n; i++)
    Vret(i) = ResInt(V(i), TheMod);
  return Vret;
}

template <typename T, typename Telt>
MyMatrix<T>
RepresentPermutationAsMatrix(FiniteMatrixGroupHelper<T, Telt> const &helper,
                             Telt const &ePerm) {
#ifdef DEBUG_MATRIX_GROUP
  std::cerr << "Beginning of RepresentPermutationAsMatrix for "
               "FiniteMatrixGroupHelper\n";
#endif
  return FindTransformation(helper.EXTfaithful, helper.EXTfaithful, ePerm);
}

template <typename T, typename Telt>
MyMatrix<T> RepresentPermutationAsMatrix(
    FiniteIsotropicMatrixGroupHelper<T, Telt> const &helper,
    Telt const &ePerm) {
#ifdef DEBUG_MATRIX_GROUP
  std::cerr << "Beginning of RepresentPermutationAsMatrix for "
               "FiniteIsotropicMatrixGroupHelper\n";
#endif
  MyMatrix<T> const &Subspace1 = helper.EXTfaithful;
  int n_rows = Subspace1.rows();
  int n_cols = Subspace1.cols();
  MyMatrix<T> Subspace2(n_rows, n_cols);
  for (int i_row = 0; i_row < n_rows; i_row++) {
    int j_row = OnPoints(i_row, ePerm);
    MyVector<T> V = GetMatrixRow(Subspace1, j_row);
    AssignMatrixRow(Subspace2, i_row, V);
  }
  std::optional<MyMatrix<T>> opt = ExtendOrthogonalIsotropicIsomorphism(
      helper.G, Subspace1, helper.G, Subspace2);
  if (!opt) {
    std::cerr << "We should have opt well defined\n";
    throw TerminalException{1};
  }
  MyMatrix<T> const &M = *opt;
  return M;
}

template <typename T, typename Tmod, typename Telt, typename Thelper>
inline typename std::enable_if<has_determining_ext<Thelper>::value,
                               typename Thelper::Treturn>::type
MatrixIntegral_GeneratePermutationGroup(
    std::vector<MyMatrix<T>> const &ListMatrGens,
    std::vector<MyMatrix<Tmod>> const &ListMatrGensMod, Thelper const &helper,
    std::vector<MyVector<Tmod>> const &O, T const &TheMod) {
#ifdef DEBUG_MATRIX_GROUP
  std::cerr << "Beginning of MatrixIntegral_GeneratePermutationGroup\n";
#endif
#ifdef TIMINGS
  SingletonTime time1;
#endif
  using Tidx = typename Telt::Tidx;
  int Osiz = O.size();
#ifdef DEBUG_MATRIX_GROUP
  std::cerr << "Osiz=" << Osiz << "\n";
#endif
  int nbRow = helper.EXTfaithful.rows();
  Tidx nbRow_tidx = nbRow;
  int siz = nbRow + Osiz;
  Telt ePermS = Telt(SortingPerm<MyVector<Tmod>, Tidx>(O));
  Tmod TheMod_mod = UniversalScalarConversion<Tmod, T>(TheMod);
  auto TheAction = [&](MyVector<Tmod> const &eClass,
                       MyMatrix<Tmod> const &eElt) -> MyVector<Tmod> {
    MyVector<Tmod> eVect = eElt.transpose() * eClass;
    return VectorMod(eVect, TheMod_mod);
  };
#ifdef TIMINGS
  SingletonTime time2;
  std::cerr << "Timing |SortingPerm|=" << ms(time1, time2) << "\n";
#endif
  Telt ePermSinv = ~ePermS;
#ifdef TIMINGS
  SingletonTime time3;
  std::cerr << "Timing |ePermSinv|=" << ms(time2, time3) << "\n";
#endif
  std::vector<Telt> ListPermGenProv;
  size_t nbGen = ListMatrGens.size();
  for (size_t iGen = 0; iGen < nbGen; iGen++) {
#ifdef TIMINGS
    SingletonTime timeB_1;
#endif
    MyMatrix<T> const &eMatrGen = ListMatrGens[iGen];
    MyMatrix<Tmod> const &eMatrGenMod = ListMatrGensMod[iGen];
    Telt ePermGen =
        GetPermutationForFiniteMatrixGroup<T, Telt, Thelper>(helper, eMatrGen);
#ifdef DEBUG_MATRIX_GROUP
    std::cerr << "iGen=" << iGen << "/" << nbGen << " ePermGen=" << ePermGen
              << "\n";
#endif
    std::vector<Tidx> v(siz);
    for (Tidx i = 0; i < nbRow_tidx; i++)
      v[i] = ePermGen.at(i);
#ifdef TIMINGS
    SingletonTime timeB_2;
    std::cerr << "Timing |v 1|=" << ms(timeB_1,timeB_2) << "\n";
#endif
    std::vector<MyVector<Tmod>> ListImage(Osiz);
    // That code below is shorter and it has the same speed as the above.
    // We keep the more complicate because it shows where most of the runtime
    // is: In computing Oprod.
    for (int iV = 0; iV < Osiz; iV++)
      ListImage[iV] = TheAction(O[iV], eMatrGenMod);
#ifdef TIMINGS
    SingletonTime timeB_3;
    std::cerr << "Timing |ListImage|=" << ms(timeB_2,timeB_3) << "\n";
#endif
    Telt ePermB = Telt(SortingPerm<MyVector<Tmod>, Tidx>(ListImage));
#ifdef TIMINGS
    SingletonTime timeB_4;
    std::cerr << "Timing |SortingPerm|=" << ms(timeB_3,timeB_4) << "\n";
#endif
    Telt ePermBinv = ~ePermB;
#ifdef TIMINGS
    SingletonTime timeB_5;
    std::cerr << "Timing |ePermBinv|=" << ms(timeB_4,timeB_5) << "\n";
#endif
    //      std::cerr << "  ePermS=" << ePermS << " ePermB=" << ePermB << "\n";
    // By the construction and above check we have
    // V1reord[i] = V1[g1.at(i)]
    // V2reord[i] = V2[g2.at(i)]
    // We have V1reord = V2reord which gets us
    // V2[i] = V1[g1 * g2^{-1}(i)]
    Telt ePermGenSelect = ePermBinv * ePermS;
#ifdef TIMINGS
    SingletonTime timeB_6;
    std::cerr << "Timing |ePermGenSelect|=" << ms(timeB_5,timeB_6) << "\n";
#endif
#ifdef DEBUG_MATRIX_GROUP
    //    std::cerr << "  ePermGenSelect=" << ePermGenSelect << "\n";
#endif
    for (int iO = 0; iO < Osiz; iO++) {
      int jO = ePermGenSelect.at(iO);
      v[nbRow + iO] = nbRow + jO;
    }
#ifdef TIMINGS
    SingletonTime timeB_7;
    std::cerr << "Timing |v 2|=" << ms(timeB_6,timeB_7) << "\n";
#endif
    Telt eNewPerm(std::move(v));
#ifdef DEBUG_MATRIX_GROUP
    for (int iO = 0; iO < Osiz; iO++) {
      MyVector<Tmod> eVect = O[iO];
      MyVector<Tmod> eVectImg1 = TheAction(eVect, eMatrGenMod);
      size_t pos = eNewPerm.at(iO + nbRow_tidx) - nbRow_tidx;
      MyVector<Tmod> eVectImg2 = O[pos];
      if (eVectImg1 != eVectImg2) {
        std::cerr << "  Inconsistency\n";
        std::cerr << "  iGen=" << iGen << " iO=" << iO << "\n";
        std::cerr << "  eVectImg1=" << StringVectorGAP(eVectImg1) << "\n";
        std::cerr << "  eVectImg2=" << StringVectorGAP(eVectImg2) << "\n";
        throw TerminalException{1};
      }
    }
#endif
    ListPermGenProv.emplace_back(std::move(eNewPerm));
#ifdef TIMINGS
    SingletonTime timeB_8;
    std::cerr << "Timing |insert|=" << ms(timeB_7,timeB_8) << "\n";
#endif
  }
#ifdef TIMINGS
  SingletonTime time4;
  std::cerr << "Timing |ListPermGenProv|=" << ms(time3,time4) << "\n";
#endif
#ifdef DEBUG_MATRIX_GROUP
  permutalib::Group<Telt, mpz_class> GRPprov(ListPermGenProv, siz);
  std::cerr << "|GRPprov|=" << GRPprov.size() << "\n";
#endif
  return {nbRow, siz, ListPermGenProv};
}



template <typename T, typename Tgroup, typename Thelper>
inline typename std::enable_if<has_determining_ext<Thelper>::value,
                               std::vector<MyMatrix<T>>>::type
MatrixIntegral_PreImageSubgroup([[maybe_unused]]
                                typename Thelper::Treturn const &eret,
                                Tgroup const& eGRP, Thelper const &helper) {
#ifdef DEBUG_MATRIX_GROUP
  std::cerr << "Beginning of MatrixIntegral_PreImageSubgroup\n";
#endif
  using Telt = typename Tgroup::Telt;
  using Tidx = typename Telt::Tidx;
#ifdef DEBUG_MATRIX_GROUP
  std::cerr << "  |eStab|=" << eStab.size() << " |eFace|=" << eFace.count()
            << "\n";
#endif
  std::vector<MyMatrix<T>> ListMatrGen;
  Tidx nbRow_tidx = helper.EXTfaithful.rows();
  for (auto &eGen : eGRP.GeneratorsOfGroup()) {
    MyMatrix<T> eMatr = RepresentPermutationAsMatrix(helper, eGen);
    ListMatrGen.emplace_back(std::move(eMatr));
  }
  return ListMatrGen;
}





template <typename T, typename Tgroup, typename Thelper>
inline typename std::enable_if<has_determining_ext<Thelper>::value,
                               std::vector<MyMatrix<T>>>::type
MatrixIntegral_Stabilizer([[maybe_unused]]
                          typename Thelper::Treturn const &eret,
                          Tgroup const &GRPperm, Thelper const &helper,
                          Face const &eFace) {
#ifdef DEBUG_MATRIX_GROUP
  std::cerr << "Beginning of MatrixIntegral_Stabilizer\n";
#endif
  using Telt = typename Tgroup::Telt;
  using Tidx = typename Telt::Tidx;
  Tgroup eStab = GRPperm.Stabilizer_OnSets(eFace);
#ifdef DEBUG_MATRIX_GROUP
  std::cerr << "  |eStab|=" << eStab.size() << " |eFace|=" << eFace.count()
            << "\n";
#endif
  std::vector<MyMatrix<T>> ListMatrGen;
  Tidx nbRow_tidx = helper.EXTfaithful.rows();
  for (auto &eGen : eStab.GeneratorsOfGroup()) {
    std::vector<Tidx> v(nbRow_tidx);
    for (Tidx i = 0; i < nbRow_tidx; i++)
      v[i] = OnPoints(i, eGen);
    Telt ePerm(std::move(v));
    MyMatrix<T> eMatr = RepresentPermutationAsMatrix(helper, ePerm);
    ListMatrGen.emplace_back(std::move(eMatr));
  }
  return ListMatrGen;
}






template <typename T, typename Tgroup, typename Thelper>
inline typename std::enable_if<has_determining_ext<Thelper>::value,
                               std::optional<MyMatrix<T>>>::type
MatrixIntegral_RepresentativeAction([[maybe_unused]]
                                    typename Thelper::Treturn const &eret,
                                    Tgroup const &GRPperm,
                                    Thelper const &helper, Face const &eFace1,
                                    Face const &eFace2) {
#ifdef DEBUG_MATRIX_GROUP
  std::cerr << "Beginning of MatrixIntegral_RepresentativeAction\n";
#endif
  using Telt = typename Tgroup::Telt;
  std::optional<Telt> opt = GRPperm.RepresentativeAction_OnSets(eFace1, eFace2);
  if (!opt) {
#ifdef DEBUG_MATRIX_GROUP
    std::cerr << "Exit while loop with proof that no equivalence exists\n";
#endif
    return {};
  }
  MyMatrix<T> eMat = RepresentPermutationAsMatrix(helper, *opt);
#ifdef DEBUG_MATRIX_GROUP
  std::cerr << "eMat=\n";
  WriteMatrix(std::cerr, eMat);
#endif
  return eMat;
}

template <typename T, typename Tmod, typename Telt, typename Thelper>
inline typename std::enable_if<
    (not has_determining_ext<Thelper>::value),
    ResultGeneratePermutationGroup_General<T, Telt>>::type
MatrixIntegral_GeneratePermutationGroup(
    std::vector<MyMatrix<T>> const &ListMatrGens,
    std::vector<MyMatrix<Tmod>> const &ListMatrGensMod,
    [[maybe_unused]] Thelper const &helper,
    std::vector<MyVector<Tmod>> const &O, T const &TheMod) {
#ifdef DEBUG_MATRIX_GROUP
  std::cerr << "Beginning of MatrixIntegral_GeneratePermutationGroup 2\n";
#endif
#ifdef TIMINGS
  std::chrono::time_point<std::chrono::system_clock> time1 =
      std::chrono::system_clock::now();
#endif
  using Tidx = typename Telt::Tidx;
  int Osiz = O.size();
#ifdef DEBUG_MATRIX_GROUP
  std::cerr << "Osiz=" << Osiz << "\n";
#endif
  int siz = Osiz;
  Telt ePermS = Telt(SortingPerm<MyVector<Tmod>, Tidx>(O));
  Tmod TheMod_mod = UniversalScalarConversion<Tmod, T>(TheMod);
  auto TheAction = [&](MyVector<Tmod> const &eClass,
                       MyMatrix<Tmod> const &eElt) -> MyVector<Tmod> {
    MyVector<Tmod> eVect = eElt.transpose() * eClass;
    return VectorMod(eVect, TheMod_mod);
  };
#ifdef TIMINGS
  std::chrono::time_point<std::chrono::system_clock> time2 =
      std::chrono::system_clock::now();
  std::cerr << "Timing |SortingPerm|="
            << std::chrono::duration_cast<std::chrono::microseconds>(time2 -
                                                                     time1)
                   .count()
            << "\n";
#endif
  Telt ePermSinv = ~ePermS;
#ifdef TIMINGS
  std::chrono::time_point<std::chrono::system_clock> time3 =
      std::chrono::system_clock::now();
  std::cerr << "Timing |ePermSinv|="
            << std::chrono::duration_cast<std::chrono::microseconds>(time3 -
                                                                     time2)
                   .count()
            << "\n";
#endif
  std::vector<Telt> ListPermGenProv;
  size_t nbGen = ListMatrGens.size();
  for (size_t iGen = 0; iGen < nbGen; iGen++) {
#ifdef TIMINGS
    std::chrono::time_point<std::chrono::system_clock> timeB_1 =
        std::chrono::system_clock::now();
#endif
    //    MyMatrix<T> const& eMatrGen=ListMatrGens[iGen];
    MyMatrix<Tmod> const &eMatrGenMod = ListMatrGensMod[iGen];
#ifdef DEBUG_MATRIX_GROUP
    std::cerr << "iGen=" << iGen << "/" << nbGen << "\n";
#endif
    std::vector<Tidx> v(siz);
#ifdef TIMINGS
    std::chrono::time_point<std::chrono::system_clock> timeB_2 =
        std::chrono::system_clock::now();
    std::cerr << "Timing |v 1|="
              << std::chrono::duration_cast<std::chrono::microseconds>(timeB_2 -
                                                                       timeB_1)
                     .count()
              << "\n";
#endif
    std::vector<MyVector<Tmod>> ListImage(Osiz);
    // That code below is shorter and it has the same speed as the above.
    // We keep the more complicate because it shows where most of the runtime
    // is: In computing Oprod.
    for (int iV = 0; iV < Osiz; iV++)
      ListImage[iV] = TheAction(O[iV], eMatrGenMod);
#ifdef TIMINGS
    std::chrono::time_point<std::chrono::system_clock> timeB_3 =
        std::chrono::system_clock::now();
    std::cerr << "Timing |ListImage|="
              << std::chrono::duration_cast<std::chrono::microseconds>(timeB_3 -
                                                                       timeB_2)
                     .count()
              << "\n";
#endif
    Telt ePermB = Telt(SortingPerm<MyVector<Tmod>, Tidx>(ListImage));
#ifdef TIMINGS
    std::chrono::time_point<std::chrono::system_clock> timeB_4 =
        std::chrono::system_clock::now();
    std::cerr << "Timing |SortingPerm|="
              << std::chrono::duration_cast<std::chrono::microseconds>(timeB_4 -
                                                                       timeB_3)
                     .count()
              << "\n";
#endif
    Telt ePermBinv = ~ePermB;
#ifdef TIMINGS
    std::chrono::time_point<std::chrono::system_clock> timeB_5 =
        std::chrono::system_clock::now();
    std::cerr << "Timing |ePermBinv|="
              << std::chrono::duration_cast<std::chrono::microseconds>(timeB_5 -
                                                                       timeB_4)
                     .count()
              << "\n";
#endif
    //      std::cerr << "  ePermS=" << ePermS << " ePermB=" << ePermB << "\n";
    // By the construction and above check we have
    // V1reord[i] = V1[g1.at(i)]
    // V2reord[i] = V2[g2.at(i)]
    // We have V1reord = V2reord which gets us
    // V2[i] = V1[g1 * g2^{-1}(i)]
    Telt ePermGenSelect = ePermBinv * ePermS;
#ifdef TIMINGS
    std::chrono::time_point<std::chrono::system_clock> timeB_6 =
        std::chrono::system_clock::now();
    std::cerr << "Timing |ePermGenSelect|="
              << std::chrono::duration_cast<std::chrono::microseconds>(timeB_6 -
                                                                       timeB_5)
                     .count()
              << "\n";
#endif
    ListPermGenProv.emplace_back(std::move(ePermGenSelect));
#ifdef TIMINGS
    std::chrono::time_point<std::chrono::system_clock> timeB_7 =
        std::chrono::system_clock::now();
    std::cerr << "Timing |insert|="
              << std::chrono::duration_cast<std::chrono::microseconds>(timeB_7 -
                                                                       timeB_6)
                     .count()
              << "\n";
#endif
  }
#ifdef TIMINGS
  std::chrono::time_point<std::chrono::system_clock> time4 =
      std::chrono::system_clock::now();
  std::cerr << "Timing |ListPermGenProv|="
            << std::chrono::duration_cast<std::chrono::microseconds>(time4 -
                                                                     time3)
                   .count()
            << "\n";
#endif
  return {0, siz, ListMatrGens, std::move(ListPermGenProv)};
}

template <typename T, typename Tgroup, typename Thelper>
inline typename std::enable_if<(not has_determining_ext<Thelper>::value),
                               std::vector<MyMatrix<T>>>::type
MatrixIntegral_PreImageSubgroup(typename Thelper::Treturn const &eret,
                                Tgroup const &eGRP, Thelper const &helper) {
#ifdef DEBUG_MATRIX_GROUP
  std::cerr << "Beginning of MatrixIntegral_Stabilizer 2\n";
#endif
  MyMatrix<T> id_matr = IdentityMat<T>(helper.n);
  return permutalib::PreImageSubgroup<Tgroup, MyMatrix<T>>(
      eret.ListMatrGens, eret.ListPermGens, id_matr, eGRP);
}


template <typename T, typename Tgroup, typename Thelper>
inline typename std::enable_if<(not has_determining_ext<Thelper>::value),
                               std::vector<MyMatrix<T>>>::type
MatrixIntegral_Stabilizer(typename Thelper::Treturn const &eret,
                          [[maybe_unused]] Tgroup const &GRPperm,
                          Thelper const &helper, Face const &eFace) {
#ifdef DEBUG_MATRIX_GROUP
  std::cerr << "Beginning of MatrixIntegral_Stabilizer 2\n";
#endif
  using Telt = typename Tgroup::Telt;
  using Tint = typename Tgroup::Tint;
  MyMatrix<T> id_matr = IdentityMat<T>(helper.n);
  return permutalib::StabilizerMatrixPermSubset<Telt, MyMatrix<T>, Tint>(
      eret.ListMatrGens, eret.ListPermGens, id_matr, eFace);
}





template <typename T, typename Tgroup, typename Thelper>
inline typename std::enable_if<(not has_determining_ext<Thelper>::value),
                               std::optional<MyMatrix<T>>>::type
MatrixIntegral_RepresentativeAction(typename Thelper::Treturn const &eret,
                                    [[maybe_unused]] Tgroup const &GRPperm,
                                    Thelper const &helper, Face const &eFace1,
                                    Face const &eFace2) {
#ifdef DEBUG_MATRIX_GROUP
  std::cerr << "Beginning of MatrixIntegral_RepresentativeAction 2\n";
#endif
  using Telt = typename Tgroup::Telt;
  using Tint = typename Tgroup::Tint;
  MyMatrix<T> id_matr = IdentityMat<T>(helper.n);
  std::optional<MyMatrix<T>> opt =
      permutalib::RepresentativeActionMatrixPermSubset<Telt, MyMatrix<T>, Tint>(
          eret.ListMatrGens, eret.ListPermGens, id_matr, eFace1, eFace2);
  return opt;
}

// The space must be defining a finite index subgroup of T^n
template <typename T, typename Tmod, typename Tgroup, typename Thelper>
std::vector<MyMatrix<T>>
LinearSpace_ModStabilizer_Tmod(std::vector<MyMatrix<T>> const &ListMatr,
                               Thelper const &helper,
                               MyMatrix<T> const &TheSpace, T const &TheMod) {
  using Telt = typename Tgroup::Telt;
  using Treturn = typename Thelper::Treturn;
  int n = helper.n;
#ifdef DEBUG_MATRIX_GROUP
  T TotSize = 1;
  for (int i = 0; i < n; i++)
    TotSize *= TheMod;
  std::cerr << "TheMod=" << TheMod << "  n=" << n << " TotSize=" << TotSize
            << "\n";

  //  std::cerr << "TheSpace=\n";
  //  WriteMatrix(std::cerr, TheSpace);
#endif
  MyMatrix<T> ModSpace = TheMod * IdentityMat<T>(n);
  MyMatrix<T> TheSpaceMod = Concatenate(TheSpace, ModSpace);
  CanSolIntMat<T> eCan = ComputeCanonicalFormFastReduction(TheSpaceMod);
  Tmod TheMod_mod = UniversalScalarConversion<Tmod, T>(TheMod);
  auto TheAction = [&](MyVector<Tmod> const &eClass,
                       MyMatrix<Tmod> const &eElt) -> MyVector<Tmod> {
    MyVector<Tmod> eVect = eElt.transpose() * eClass;
    return VectorMod(eVect, TheMod_mod);
  };
  // This is the part of the enumeration where we have problems.
  // We have too many vectors to consider whih sinks the algorithm.
  // The difficulty of the work is that we have to deal with globally
  // invariant sets of vectors. This is difficult to manipulate in practice.
  // We could look at specific generators, but that is unlikely to
  // radically change things.
  //
  // We could look at the quotient. (Z_d)^n / TheSpace and look for point
  // stabilizers Maybe we can translate to classes easily and
  auto IsStabilizing = [&](std::vector<MyMatrix<T>> const &ListMatrInp)
      -> std::optional<MyVector<Tmod>> {
    for (int i = 0; i < n; i++) {
      MyVector<T> eVect = GetMatrixRow(TheSpace, i);
      for (auto &eGen : ListMatrInp) {
        MyVector<T> eVectG = eGen.transpose() * eVect;
        bool test = CanTestSolutionIntMat(eCan, eVectG);
        if (!test) {
#ifdef DEBUG_MATRIX_GROUP
          std::cerr << "i=" << i << "  eVect=" << StringVectorGAP(eVect)
                    << "\n";
#endif
          return ModuloReductionVector<T, Tmod>(eVect, TheMod);
        }
      }
    }
    return {};
  };
  std::vector<MyMatrix<T>> ListMatrRet = ListMatr;
  std::vector<MyMatrix<Tmod>> ListMatrRetMod =
      ModuloReductionStdVectorMatrix<T, Tmod>(ListMatrRet, TheMod);
  while (true) {
#ifdef TIMINGS
    std::chrono::time_point<std::chrono::system_clock> time1 =
        std::chrono::system_clock::now();
#endif
    std::optional<MyVector<Tmod>> opt = IsStabilizing(ListMatrRet);
#ifdef TIMINGS
    std::chrono::time_point<std::chrono::system_clock> time2 =
        std::chrono::system_clock::now();
    std::cerr << "Timing |IsStabilizing|="
              << std::chrono::duration_cast<std::chrono::microseconds>(time2 -
                                                                       time1)
                     .count()
              << "\n";
#endif
    if (!opt) {
#ifdef DEBUG_MATRIX_GROUP
      std::cerr << "Exiting the loop\n";
#endif
      break;
    }
    const MyVector<Tmod> &V = *opt;
    std::vector<MyVector<Tmod>> O =
        OrbitComputation(ListMatrRetMod, V, TheAction);
#ifdef DEBUG_MATRIX_GROUP
    std::cerr << "Timing |O|=" << O.size() << "\n";
#endif
#ifdef TIMINGS
    std::chrono::time_point<std::chrono::system_clock> time3 =
        std::chrono::system_clock::now();
    std::cerr << "Timing |OrbitComputation|="
              << std::chrono::duration_cast<std::chrono::microseconds>(time3 -
                                                                       time2)
                     .count()
              << "\n";
#endif

    Treturn eret =
        MatrixIntegral_GeneratePermutationGroup<T, Tmod, Telt, Thelper>(
            ListMatrRet, ListMatrRetMod, helper, O, TheMod);

    Tgroup GRPwork(eret.ListPermGens, eret.siz);
    Face eFace = GetFace<T, Tmod>(eret.nbRow, O, TheSpaceMod);
#ifdef MATRIX_GROUP_DIAGNOSTICS
    std::cerr << "ModStabilizer TheMod=" << TheMod << " |O|=" << O.size()
              << " |GRPwork|=" << GRPwork.size() << " |eFace|=" << eFace.count()
              << "\n";
#endif

    ListMatrRet = MatrixIntegral_Stabilizer<T, Tgroup, Thelper>(eret, GRPwork,
                                                                helper, eFace);
    ListMatrRetMod =
        ModuloReductionStdVectorMatrix<T, Tmod>(ListMatrRet, TheMod);
  }
  return ListMatrRet;
}

template <typename T, typename Tgroup, typename Thelper>
std::vector<MyMatrix<T>>
LinearSpace_ModStabilizer(std::vector<MyMatrix<T>> const &ListMatr,
                          Thelper const &helper, MyMatrix<T> const &TheSpace,
                          T const &TheMod) {
  T max_size = (TheMod - 1) * (TheMod - 1) * TheSpace.rows();
  if (max_size < T(std::numeric_limits<uint8_t>::max())) {
    return LinearSpace_ModStabilizer_Tmod<T, uint8_t, Tgroup, Thelper>(
        ListMatr, helper, TheSpace, TheMod);
  }
  if (max_size < T(std::numeric_limits<uint16_t>::max())) {
    return LinearSpace_ModStabilizer_Tmod<T, uint16_t, Tgroup, Thelper>(
        ListMatr, helper, TheSpace, TheMod);
  }
  if (max_size < T(std::numeric_limits<uint32_t>::max())) {
    return LinearSpace_ModStabilizer_Tmod<T, uint32_t, Tgroup, Thelper>(
        ListMatr, helper, TheSpace, TheMod);
  }
  std::cerr << "Failed to find a matching arithmetic type. Quite unlikely "
               "objectively\n";
  throw TerminalException{1};
}

template <typename T>
using ResultTestModEquivalence =
    std::pair<std::vector<MyMatrix<T>>, MyMatrix<T>>;

/*
  We need a number of separate functions:
  ---The list of matrices has to be separated from the helper data like the
  EXTfaithful
  ---Function that creates the permutation representation given the ListMatrMat
  and the helper
  ---A function for computing the
 */
template <typename T, typename Tmod, typename Tgroup, typename Thelper>
std::optional<ResultTestModEquivalence<T>>
LinearSpace_ModEquivalence_Tmod(std::vector<MyMatrix<T>> const &ListMatr,
                                Thelper const &helper,
                                MyMatrix<T> const &TheSpace1,
                                MyMatrix<T> const &TheSpace2, T const &TheMod) {
  using Telt = typename Tgroup::Telt;
  using Treturn = typename Thelper::Treturn;
  int n = TheSpace1.rows();
#ifdef DEBUG_MATRIX_GROUP
  std::cerr << "------------------------------------------------------\n";
  std::cerr << "LinearSpace_ModEquivalence, TheMod=" << TheMod << "\n";
  std::cerr << "TheSpace1=\n";
  WriteMatrix(std::cerr, TheSpace1);
  std::cerr << "TheSpace2=\n";
  WriteMatrix(std::cerr, TheSpace2);
  std::cerr << "det(TheSpace1)=" << DeterminantMat(TheSpace1)
            << " det(TheSpace2)=" << DeterminantMat(TheSpace2) << "\n";
#endif
  MyMatrix<T> ModSpace = TheMod * IdentityMat<T>(n);
  MyMatrix<T> TheSpace1Mod = Concatenate(TheSpace1, ModSpace);
  MyMatrix<T> TheSpace2Mod = Concatenate(TheSpace2, ModSpace);
  std::vector<MyMatrix<T>> ListMatrRet = ListMatr;
  std::vector<MyMatrix<Tmod>> ListMatrRetMod =
      ModuloReductionStdVectorMatrix<T, Tmod>(ListMatrRet, TheMod);
  MyMatrix<T> eElt = IdentityMat<T>(n);
  Tmod TheMod_mod = UniversalScalarConversion<Tmod, T>(TheMod);
  auto TheAction = [&](MyVector<Tmod> const &eClass,
                       MyMatrix<Tmod> const &eElt) -> MyVector<Tmod> {
    MyVector<Tmod> eVect = eElt.transpose() * eClass;
    return VectorMod(eVect, TheMod_mod);
  };
  CanSolIntMat<T> eCan = ComputeCanonicalFormFastReduction(TheSpace2Mod);
  auto IsEquiv =
      [&](MyMatrix<T> const &eEquiv) -> std::optional<MyVector<Tmod>> {
    MyMatrix<T> TheSpace1img = TheSpace1 * eEquiv;
    for (int i = 0; i < n; i++) {
      MyVector<T> eVect = GetMatrixRow(TheSpace1img, i);
      bool test = CanTestSolutionIntMat(eCan, eVect);
      if (!test) {
#ifdef DEBUG_MATRIX_GROUP
        std::cerr << "   i=" << i << " eVect=" << StringVectorGAP(eVect)
                  << "\n";
        std::cerr << "   eEquiv=\n";
        WriteMatrix(std::cerr, eEquiv);
#endif
        return ModuloReductionVector<T, Tmod>(eVect, TheMod);
      }
    }
    return {};
  };
  auto IsStabilizing = [&](std::vector<MyMatrix<T>> const &ListMat)
      -> std::optional<MyVector<Tmod>> {
    for (auto &eGen : ListMat) {
      MyMatrix<T> TheSpace2img = TheSpace2 * eGen;
      for (int i = 0; i < n; i++) {
        MyVector<T> eVect = GetMatrixRow(TheSpace2img, i);
        bool test = CanTestSolutionIntMat(eCan, eVect);
        if (!test)
          return ModuloReductionVector<T, Tmod>(eVect, TheMod);
      }
    }
    return {};
  };
  while (true) {
    std::optional<MyVector<Tmod>> test1 = IsEquiv(eElt);
    std::optional<MyVector<Tmod>> test2 = IsStabilizing(ListMatrRet);
    if (!test1 && !test2) {
#ifdef DEBUG_MATRIX_GROUP
      std::cerr << "eElt and GRPwork are correct. Exiting\n";
#endif
      ResultTestModEquivalence<T> res{ListMatrRet, eElt};
      return res;
    }
    if (test1) {
      MyVector<Tmod> const &V = *test1;
      std::vector<MyVector<Tmod>> O =
          OrbitComputation(ListMatrRetMod, V, TheAction);
#ifdef DEBUG_MATRIX_GROUP
      std::cerr << "|O|=" << O.size() << "\n";
#endif

      Treturn eret =
          MatrixIntegral_GeneratePermutationGroup<T, Tmod, Telt, Thelper>(
              ListMatrRet, ListMatrRetMod, helper, O, TheMod);
#ifdef DEBUG_MATRIX_GROUP
      if constexpr (has_determining_ext<Thelper>::value) {
        for (size_t iGen = 0; iGen < ListMatrRet.size(); iGen++) {
          Telt ePerm = eret.ListPermGens[iGen];
          std::cerr << "ePerm=" << ePerm;
          MyMatrix<T> eMatr = ListMatrRet[iGen];
          MyMatrix<T> M2 = RepresentPermutationAsMatrix(helper, ePerm);
          if (eMatr != M2) {
            std::cerr << " INCORRECT\n";
          } else {
            std::cerr << " correct\n";
          }
        }
      }
#endif
      Tgroup GRPperm(eret.ListPermGens, eret.siz);

      MyMatrix<T> TheSpace1work = TheSpace1 * eElt;
      MyMatrix<T> TheSpace1workMod = Concatenate(TheSpace1work, ModSpace);
#ifdef DEBUG_MATRIX_GROUP
      std::cerr << "eElt=\n";
      WriteMatrix(std::cerr, eElt);
#endif
      Face eFace1 = GetFace<T, Tmod>(eret.nbRow, O, TheSpace1workMod);
      Face eFace2 = GetFace<T, Tmod>(eret.nbRow, O, TheSpace2Mod);
#ifdef DEBUG_MATRIX_GROUP
      std::cerr << "nbRow=" << eret.nbRow << " eFace1=" << StringFace(eFace1)
                << " eFace2=" << StringFace(eFace2) << "\n";
#endif
      if (eFace1.count() == 0 && eFace2.count() == 0) {
        std::cerr
            << "Error in LinearSpace_ModEquivalence. |eFace1| = |eFace2| = 0\n";
        std::cerr << "Clear bug\n";
        throw TerminalException{1};
      }
#ifdef MATRIX_GROUP_DIAGNOSTICS
      std::cerr << "ModEquivalence 1 TheMod=" << TheMod << " |O|=" << O.size()
                << " |GRPperm|=" << GRPperm.size()
                << " |eFace1|=" << eFace1.count()
                << " |eFace2|=" << eFace2.count() << "\n";
#endif
      std::optional<MyMatrix<T>> opt =
          MatrixIntegral_RepresentativeAction<T, Tgroup, Thelper>(
              eret, GRPperm, helper, eFace1, eFace2);
      if (!opt) {
#ifdef DEBUG_MATRIX_GROUP
        std::cerr << "Exit while loop with proof that no equivalence exists\n";
#endif
        return {};
      }
      MyMatrix<T> const &M = *opt;
#ifdef DEBUG_MATRIX_GROUP
      MyMatrix<Tmod> Mmod = ModuloReductionMatrix<T, Tmod>(M, TheMod);
      Treturn fret =
          MatrixIntegral_GeneratePermutationGroup<T, Tmod, Telt, Thelper>(
              {M}, {Mmod}, helper, O, TheMod);
      if (fret.ListPermGens.size() != 1) {
        std::cerr << "ListPermGens does not have the right length\n";
        throw TerminalException{1};
      }
      Telt ePerm = fret.ListPermGens[0];
      std::cerr << "ePerm=" << ePerm << "\n";
      if constexpr (has_determining_ext<Thelper>::value) {
        MyMatrix<T> M2 = RepresentPermutationAsMatrix(helper, ePerm);
        if (M != M2) {
          std::cerr << "The matrix is not the original one\n";
          throw TerminalException{1};
        }
      }
      Face eFace1_img = OnFace(eFace1, ePerm);
      if (eFace1_img != eFace2) {
        std::cerr << "eFace1 not maššed to eFace2\n";
        std::cerr << "|eFace1|=" << eFace1.size() << "\n";
        std::cerr << "nbRow=" << fret.nbRow << " siz=" << fret.siz << "\n";
        std::cerr << "eFace1_img=" << StringFace(eFace1_img) << "\n";
        throw TerminalException{1};
      }
#endif
      ListMatrRet = MatrixIntegral_Stabilizer<T, Tgroup, Thelper>(
          eret, GRPperm, helper, eFace2);
      ListMatrRetMod =
          ModuloReductionStdVectorMatrix<T, Tmod>(ListMatrRet, TheMod);
      eElt = eElt * M;
    } else {
      MyVector<Tmod> const &V = *test2;
      std::vector<MyVector<Tmod>> O =
          OrbitComputation(ListMatrRetMod, V, TheAction);
#ifdef DEBUG_MATRIX_GROUP
      std::cerr << "|O|=" << O.size() << "\n";
#endif
      Treturn eret =
          MatrixIntegral_GeneratePermutationGroup<T, Tmod, Telt, Thelper>(
              ListMatrRet, ListMatrRetMod, helper, O, TheMod);
      Tgroup GRPperm(eret.ListPermGens, eret.siz);
      Face eFace2 = GetFace<T, Tmod>(eret.nbRow, O, TheSpace2Mod);
#ifdef MATRIX_GROUP_DIAGNOSTICS
      std::cerr << "ModEquivalence 2 TheMod=" << TheMod << " |O|=" << O.size()
                << " |GRPperm|=" << GRPperm.size()
                << " |eFace2|=" << eFace2.count() << "\n";
#endif
      ListMatrRet = MatrixIntegral_Stabilizer<T, Tgroup, Thelper>(
          eret, GRPperm, helper, eFace2);
      ListMatrRetMod =
          ModuloReductionStdVectorMatrix<T, Tmod>(ListMatrRet, TheMod);
    }
  }
}

template <typename T, typename Tgroup, typename Thelper>
std::optional<ResultTestModEquivalence<T>>
LinearSpace_ModEquivalence(std::vector<MyMatrix<T>> const &ListMatr,
                           Thelper const &helper, MyMatrix<T> const &TheSpace1,
                           MyMatrix<T> const &TheSpace2, T const &TheMod) {
  T max_size = (TheMod - 1) * (TheMod - 1) * TheSpace1.rows();
  if (max_size < T(std::numeric_limits<uint8_t>::max())) {
    return LinearSpace_ModEquivalence_Tmod<T, uint8_t, Tgroup, Thelper>(
        ListMatr, helper, TheSpace1, TheSpace2, TheMod);
  }
  if (max_size < T(std::numeric_limits<uint16_t>::max())) {
    return LinearSpace_ModEquivalence_Tmod<T, uint16_t, Tgroup, Thelper>(
        ListMatr, helper, TheSpace1, TheSpace2, TheMod);
  }
  if (max_size < T(std::numeric_limits<uint32_t>::max())) {
    return LinearSpace_ModEquivalence_Tmod<T, uint32_t, Tgroup, Thelper>(
        ListMatr, helper, TheSpace1, TheSpace2, TheMod);
  }
  std::cerr << "Failed to find a matching arithmetic type. Quite unlikely "
               "objectively\n";
  throw TerminalException{1};
}

template <typename T, typename Tgroup, typename Thelper>
std::vector<MyMatrix<T>>
LinearSpace_Stabilizer(std::vector<MyMatrix<T>> const &ListMatr,
                       Thelper const &helper, MyMatrix<T> const &TheSpace) {
  int n = helper.n;
#ifdef DEBUG_MATRIX_GROUP
  //  std::cerr << "TheSpace=\n";
  //  WriteMatrixGAP(std::cerr, TheSpace);
  //  std::cerr << "\n";
  std::cerr << "det(TheSpace)=" << DeterminantMat(TheSpace) << "\n";
#endif
  CanSolIntMat<T> eCan = ComputeCanonicalFormFastReduction(TheSpace);
  auto IsStabilizing = [&](std::vector<MyMatrix<T>> const &LMat) -> bool {
    for (int i = 0; i < n; i++) {
      MyVector<T> eVect = GetMatrixRow(TheSpace, i);
      for (auto &eGen : LMat) {
        MyVector<T> eVectG = eGen.transpose() * eVect;
        bool test = CanTestSolutionIntMat(eCan, eVectG);
        if (!test) {
          return false;
        }
      }
    }
#ifdef DEBUG_MATRIX_GROUP
    std::cerr << "Leaving IsStabilzing: true\n";
#endif
    return true;
  };
  if (IsStabilizing(ListMatr))
    return ListMatr;
  T LFact = LinearSpace_GetDivisor(TheSpace);
  std::vector<T> eList = FactorsInt(LFact);
  int siz = eList.size();
#ifdef DEBUG_MATRIX_GROUP
  std::cerr << "LFact=" << LFact << " siz=" << siz << "\n";
#endif
  std::vector<MyMatrix<T>> ListMatrRet = ListMatr;
  for (int i = 1; i <= siz; i++) {
    T TheMod = 1;
    for (int j = 0; j < i; j++)
      TheMod *= eList[j];
    ListMatrRet = LinearSpace_ModStabilizer<T, Tgroup>(ListMatrRet, helper,
                                                       TheSpace, TheMod);
    if (IsStabilizing(ListMatrRet))
      return ListMatrRet;
  }
  if (!IsStabilizing(ListMatrRet)) {
    std::cerr << "Error in LinearSpace_Stabilizer\n";
    throw TerminalException{1};
  }
  return ListMatrRet;
}

template <typename T, typename Tgroup, typename Thelper>
std::optional<MyMatrix<T>>
LinearSpace_Equivalence(std::vector<MyMatrix<T>> const &ListMatr,
                        Thelper const &helper, MyMatrix<T> const &InSpace1,
                        MyMatrix<T> const &InSpace2) {
  static_assert(is_ring_field<T>::value,
                "Requires T to be a field in LinearSpace_Equivalence");
#ifdef DEBUG_MATRIX_GROUP
  std::cerr << "Beginning of LinearSpace_Equivalence\n";
  std::cerr << "InSpace1=\n";
  WriteMatrix(std::cerr, InSpace1);
  std::cerr << "InSpace2=\n";
  WriteMatrix(std::cerr, InSpace2);
  std::cerr << "Det(InSpace1)=" << DeterminantMat(InSpace1)
            << " Det(InSpace2)=" << DeterminantMat(InSpace2) << "\n";
#endif
  FractionMatrix<T> eRec1 = RemoveFractionMatrixPlusCoeff(InSpace1);
  FractionMatrix<T> eRec2 = RemoveFractionMatrixPlusCoeff(InSpace2);
#ifdef DEBUG_MATRIX_GROUP
  std::cerr << "eRec1.TheMult=" << eRec1.TheMult
            << " eRec2.TheMult=" << eRec2.TheMult << "\n";
#endif
  if (eRec1.TheMult != eRec2.TheMult)
    return {};
  MyMatrix<T> const &TheSpace1 = eRec1.TheMat;
  MyMatrix<T> const &TheSpace2 = eRec2.TheMat;
  //
  int n = TheSpace1.rows();
  T LFact1 = LinearSpace_GetDivisor(TheSpace1);
  T LFact2 = LinearSpace_GetDivisor(TheSpace2);
#ifdef DEBUG_MATRIX_GROUP
  std::cerr << "LFact1 = " << LFact1 << "\n";
  std::cerr << "LFact2 = " << LFact2 << "\n";
#endif
  if (LFact1 != LFact2) {
    return {};
  }
  std::vector<T> eList = FactorsInt(LFact1);
#ifdef DEBUG_MATRIX_GROUP
  std::cerr << "eList =";
  for (auto &eVal : eList)
    std::cerr << " " << eVal;
  std::cerr << "\n";
#endif
  CanSolIntMat<T> eCan = ComputeCanonicalFormFastReduction(TheSpace2);
  auto IsEquivalence = [&](MyMatrix<T> const &eEquiv) -> bool {
    for (int i = 0; i < n; i++) {
      MyVector<T> eVect = GetMatrixRow(TheSpace1, i);
      MyVector<T> eVectG = eEquiv.transpose() * eVect;
      bool test = CanTestSolutionIntMat(eCan, eVectG);
      if (!test)
        return false;
    }
    return true;
  };
  std::vector<MyMatrix<T>> ListMatrWork = ListMatr;
  int siz = eList.size();
  std::vector<MyMatrix<T>> ListMatrRet = ListMatr;
  MyMatrix<T> eElt = IdentityMat<T>(n);
  for (int i = 1; i <= siz; i++) {
    if (IsEquivalence(eElt))
      return eElt;
    T TheMod = 1;
    for (int j = 0; j < i; j++)
      TheMod *= eList[j];
    MyMatrix<T> TheSpace1Img = TheSpace1 * eElt;
    std::optional<ResultTestModEquivalence<T>> opt =
        LinearSpace_ModEquivalence<T, Tgroup, Thelper>(
            ListMatrWork, helper, TheSpace1Img, TheSpace2, TheMod);
    if (!opt) {
#ifdef DEBUG_MATRIX_GROUP
      std::cerr << "LinearSpace_ModEquivalence failed so we exit here\n";
#endif
      return {};
    }
    eElt = eElt * (opt->second);
    ListMatrWork = opt->first;
  }
  if (!IsEquivalence(eElt)) {
    std::cerr << "Error in LinearSpace_Equivalence\n";
    throw TerminalException{1};
  }
  return eElt;
}

template <typename T, typename Tgroup>
std::vector<MyMatrix<T>> LinPolytopeIntegral_Automorphism_Subspaces(
    std::vector<MyMatrix<T>> const &ListMatr, MyMatrix<T> const &EXTfaithful) {
  static_assert(
      is_ring_field<T>::value,
      "Requires T to be a field in LinPolytopeIntegral_Automorphism_Subspaces");
  using Telt = typename Tgroup::Telt;
  MyMatrix<T> eBasis = GetZbasis(EXTfaithful);
  MyMatrix<T> InvBasis = Inverse(eBasis);
  MyMatrix<T> EXTbas = EXTfaithful * InvBasis;
  std::vector<MyMatrix<T>> ListMatrGens;
  for (auto &eGen : ListMatr) {
    MyMatrix<T> NewGen = eBasis * eGen * InvBasis;
    if (!IsIntegralMatrix(NewGen)) {
      std::cerr << "Clear error in the code\n";
      throw TerminalException{1};
    }
    ListMatrGens.push_back(NewGen);
  }
  FiniteMatrixGroupHelper<T, Telt> helper =
      ComputeFiniteMatrixGroupHelper<T, Telt>(EXTbas);
  MyMatrix<T> LattToStab = RemoveFractionMatrix(Inverse(eBasis));

  std::vector<MyMatrix<T>> LMat =
      LinearSpace_Stabilizer<T, Tgroup>(ListMatrGens, helper, LattToStab);
  std::vector<MyMatrix<T>> ListMatrGensB;
  for (auto &eGen : LMat) {
    MyMatrix<T> NewGen = InvBasis * eGen * eBasis;
    if (!IsIntegralMatrix(NewGen)) {
      std::cerr << "Clear error in the code\n";
      throw TerminalException{1};
    }
    ListMatrGensB.push_back(NewGen);
  }
  return ListMatrGensB;
}

template <typename T, typename Tgroup>
std::optional<MyMatrix<T>> LinPolytopeIntegral_Isomorphism_Method4(
    MyMatrix<T> const &EXT1_T, MyMatrix<T> const &EXT2_T, Tgroup const &GRP1,
    typename Tgroup::Telt const &ePerm,
    std::function<bool(MyMatrix<T>)> const &IsMatrixCorrect) {
  using Telt = typename Tgroup::Telt;
  for (auto &fPerm : GRP1) {
    Telt eEquivCand = fPerm * ePerm;
    MyMatrix<T> eBigMat = FindTransformation(EXT1_T, EXT2_T, eEquivCand);
    if (IsMatrixCorrect(eBigMat))
      return eBigMat;
  }
  return {};
}

template <typename T, typename Tgroup>
Tgroup LinPolytopeIntegral_Stabilizer_Method4(
    MyMatrix<T> const &EXT_T, Tgroup const &GRPisom,
    std::function<bool(MyMatrix<T>)> const &IsMatrixCorrect) {
  static_assert(
      is_ring_field<T>::value,
      "Requires T to be a field in LinPolytopeIntegral_Stabilizer_Method4");
  using Telt = typename Tgroup::Telt;
  int nbVert = EXT_T.rows();
  std::vector<Telt> generatorList;
  Tgroup GRPret(nbVert);
  auto fInsert = [&](Telt const &ePerm) -> void {
    bool test = GRPret.isin(ePerm);
    if (!test) {
      generatorList.push_back(ePerm);
      GRPret = Tgroup(generatorList, nbVert);
    }
  };
  for (auto &ePerm : GRPisom) {
    MyMatrix<T> eBigMat = FindTransformation(EXT_T, EXT_T, ePerm);
    if (IsMatrixCorrect(eBigMat))
      fInsert(ePerm);
  }
  return GRPret;
}

template <typename T, typename Tgroup>
Tgroup LinPolytopeIntegral_Stabilizer_Method8(MyMatrix<T> const &EXT_T,
                                              Tgroup const &GRPisom) {
  static_assert(
      is_ring_field<T>::value,
      "Requires T to be a field in LinPolytopeIntegral_Stabilizer_Method8");
  using Telt = typename Tgroup::Telt;
  int nbVert = EXT_T.rows();
  std::vector<MyMatrix<T>> ListMatrGen;
  for (auto &eGen : GRPisom.GeneratorsOfGroup()) {
    MyMatrix<T> eMat = FindTransformation(EXT_T, EXT_T, eGen);
    ListMatrGen.push_back(eMat);
  }
  using Thelper = FiniteMatrixGroupHelper<T, Telt>;
  Thelper helper = ComputeFiniteMatrixGroupHelper<T, Telt>(EXT_T);
  std::vector<MyMatrix<T>> ListMatr =
      LinPolytopeIntegral_Automorphism_Subspaces<T, Tgroup>(ListMatrGen, EXT_T);
  std::vector<Telt> ListPermGens;
  for (auto &eMatr : ListMatr)
    ListPermGens.push_back(
        GetPermutationForFiniteMatrixGroup<T, Telt, Thelper>(helper, eMatr));
  return Tgroup(ListPermGens, nbVert);
}

template <typename T, typename Tgroup>
std::optional<MyMatrix<T>> LinPolytopeIntegral_Isomorphism_Subspaces(
    MyMatrix<T> const &EXT1_T, MyMatrix<T> const &EXT2_T,
    std::vector<MyMatrix<T>> const &ListMatrGens2,
    typename Tgroup::Telt const &eEquiv) {
  static_assert(
      is_ring_field<T>::value,
      "Requires T to be a field in LinPolytopeIntegral_Isomorphism_Subspaces");
#ifdef DEBUG_MATRIX_GROUP
  std::cerr << "Beginning of LinPolytopeIntegral_Isomorphism_Subspaces\n";
#endif
  using Telt = typename Tgroup::Telt;
  MyMatrix<T> eBasis1 = GetZbasis(EXT1_T);
  MyMatrix<T> eBasis2 = GetZbasis(EXT2_T);
  MyMatrix<T> InvBasis1 = Inverse(eBasis1);
  MyMatrix<T> InvBasis2 = Inverse(eBasis2);
  MyMatrix<T> EXTbas1 = EXT1_T * InvBasis1;
  MyMatrix<T> EXTbas2 = EXT2_T * InvBasis2;
#ifdef DEBUG_MATRIX_GROUP
  std::cerr << "EXT1_T=\n";
  WriteMatrix(std::cerr, EXT1_T);
  std::cerr << "EXT2_T=\n";
  WriteMatrix(std::cerr, EXT2_T);
  if (EXT1_T.rows() == EXT1_T.cols()) {
    std::cerr << "det(EXT1_T)=" << DeterminantMat(EXT1_T) << "\n";
  }
  if (EXT2_T.rows() == EXT2_T.cols()) {
    std::cerr << "det(EXT2_T)=" << DeterminantMat(EXT2_T) << "\n";
  }
  std::cerr << "eBasis1=\n";
  WriteMatrix(std::cerr, eBasis1);
  std::cerr << "eBasis2=\n";
  WriteMatrix(std::cerr, eBasis2);
  std::cerr << "EXTbas1=\n";
  WriteMatrix(std::cerr, EXTbas1);
  std::cerr << "EXTbas2=\n";
  WriteMatrix(std::cerr, EXTbas2);
#endif
  //
  MyMatrix<T> TheMatEquiv = FindTransformation(EXTbas1, EXTbas2, eEquiv);
#ifdef DEBUG_MATRIX_GROUP
  std::cerr << "TheMatEquiv=\n";
  WriteMatrix(std::cerr, TheMatEquiv);
#endif
  std::vector<MyMatrix<T>> ListMatrGen;
  for (auto &eGen : ListMatrGens2) {
    MyMatrix<T> NewGen = eBasis2 * eGen * InvBasis2;
    ListMatrGen.push_back(NewGen);
  }
  FiniteMatrixGroupHelper<T, Telt> helper =
      ComputeFiniteMatrixGroupHelper<T, Telt>(EXTbas2);
  MyMatrix<T> eLatt1 = Inverse(eBasis1) * TheMatEquiv;
  MyMatrix<T> eLatt2 = Inverse(eBasis2);
#ifdef DEBUG_MATRIX_GROUP
  std::cerr << "eLatt1=\n";
  WriteMatrix(std::cerr, eLatt1);
  std::cerr << "eLatt2=\n";
  WriteMatrix(std::cerr, eLatt2);
#endif
  std::optional<MyMatrix<T>> eSpaceEquiv =
      LinearSpace_Equivalence<T, Tgroup>(ListMatrGen, helper, eLatt1, eLatt2);
  if (!eSpaceEquiv)
    return {};
  MyMatrix<T> eMatFinal = InvBasis1 * TheMatEquiv * (*eSpaceEquiv) * eBasis2;
  if (!IsIntegralMatrix(eMatFinal)) {
    std::cerr << "eMatFinal should be integral\n";
    throw TerminalException{1};
  }
  return eMatFinal;
}

// GRP1 is a group of automorphism preserving EXT1_T
// ePerm is a transformation mapping EXT1 to EXT2.
// We are searching for a transformation h in GRP1 such that
// h * ePerm is an integral transformation.
template <typename T, typename Tgroup>
std::optional<MyMatrix<T>> LinPolytopeIntegral_Isomorphism_Method8(
    MyMatrix<T> const &EXT1_T, MyMatrix<T> const &EXT2_T, Tgroup const &GRP1,
    typename Tgroup::Telt const &ePerm) {
  using Telt = typename Tgroup::Telt;
  std::vector<MyMatrix<T>> ListMatrGens;
  std::vector<Telt> LGen = GRP1.GeneratorsOfGroup();
  for (auto &eGen : LGen) {
    Telt ePermGen = (~ePerm) * eGen * ePerm;
    MyMatrix<T> eMatr = FindTransformation(EXT2_T, EXT2_T, ePermGen);
    ListMatrGens.push_back(eMatr);
  }
  return LinPolytopeIntegral_Isomorphism_Subspaces<T, Tgroup>(
      EXT1_T, EXT2_T, ListMatrGens, ePerm);
}

#endif // SRC_POLY_MATRIXGROUP_H_
