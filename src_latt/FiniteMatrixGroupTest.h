// Copyright (C) 2022 Mathieu Dutour Sikiric <mathieu.dutour@gmail.com>
#ifndef SRC_GROUP_FINITEMATRIXGROUPTEST_H_
#define SRC_GROUP_FINITEMATRIXGROUPTEST_H_

// clang-format off
#include "FiniteMatrixGroupFund.h"
#include "Tspace_SearchPositiveMatrices.h"
#include <vector>
// clang-format on

/*
  Trying to find if the group generated by integral matrices
  is finite or not.
  Two methods are used:
  * The positive definite invariant matrix method.
  * The generation of all elements with termination by high torsion elements.
  ---
  Both methods are used at the same time.
  One method works well for a class a group and the other for another
  so we have good chance of success together.
 */



/*
  Test group finiteness.
  An integral matrix group G is finite if and only if it preserves
  a positive definite quadratic form.
  Proof:
  * If G is finite then take the identity and the average under G. The average
    is positive definite and is preserved.
  * If G preserves a positive definite quadratic form Q, then G is a subgroup
    of the stabilizer of Q. The stabilizer of Q is finite so that follows.

  If a matrix group is finite then it preserves a positive definite quadratic form
  ---
  We only need to determine finiteness, so no need to care too much about issues
  of transpose and similar.
 */
template<typename T, typename Tint>
bool test_finiteness_group_posdef(std::vector<MyMatrix<Tint>> const& ListGens, std::ostream &os) {
  if (ListGens.size() == 0) {
    // No generators, so the group is trivial.
    return true;
  }
  int n = ListGens[0].rows();
  std::vector<MyMatrix<T>> ListGens_T = UniversalStdVectorMatrixConversion<T,Tint>(ListGens);
  std::vector<MyMatrix<T>> ListMat = BasisInvariantForm<T>(n, ListGens_T, os);
  if (ListMat.size() == 0) {
    // No invariant matrix
    return false;
  }
  std::optional<MyMatrix<T>> opt = GetOnePositiveDefiniteMatrix<T,Tint>(ListMat, os);
  if (opt) {
    return true;
  } else {
    return false;
  }
}

template<typename T, typename Tint>
bool test_finiteness_group(std::vector<MyMatrix<Tint>> const& ListGensInp, std::ostream &os) {
  if (ListGensInp.size() == 0) {
    // No generators, so the group is trivial.
    return true;
  }
  std::vector<MyMatrix<Tint>> ListGens = ExhaustiveReductionComplexityGroupMatrix(ListGensInp, os);
  int n = ListGens[0].rows();
  std::vector<MyMatrix<T>> ListGens_T = UniversalStdVectorMatrixConversion<T,Tint>(ListGens);
  std::vector<MyMatrix<T>> ListMat = BasisInvariantForm<T>(n, ListGens_T, os);
  if (ListMat.size() == 0) {
    // No invariant matrix
    return false;
  }
  std::vector<MyVector<Tint>> ListV_init = get_initial_vector_test_v<Tint>(n, {}, os);
  SearcherPositiveDefiniteMatrix<T,Tint> spdm(ListMat, ListV_init, os);
  FiniteMatrixGroupTest<Tint> fmgt(ListGens, os);
  while(true) {
    //
    // Trying the matrix method
    //
    NanosecondTime time_spdm;
    spdm.one_iteration();
    int64_t n_nanoseconds = time_spdm.const_eval_int64();
    std::optional<std::optional<MyMatrix<T>>> const& pos_def = spdm.get_pos_def();
    if (pos_def) {
      std::optional<MyMatrix<T>> const& result = *pos_def;
      if (result) {
        return true;
      } else {
        return false;
      }
    }
    //
    // Now the iteration
    //
    fmgt.timed_increase(n_nanoseconds);
    std::optional<bool> result = fmgt.get_status();
    if (result) {
      return *result;
    }
  }
}

// clang-format off
#endif  // SRC_GROUP_FINITEMATRIXGROUPTEST_H_
// clang-format on
