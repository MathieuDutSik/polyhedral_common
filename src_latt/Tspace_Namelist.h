// Copyright (C) 2023 Mathieu Dutour Sikiric <mathieu.dutour@gmail.com>
#ifndef SRC_LATT_TSPACE_NAMELIST_H_
#define SRC_LATT_TSPACE_NAMELIST_H_

// clang-format off
#include "Namelist.h"
#include "MatrixGroupAverage.h"
#include <map>
#include <vector>
#include <string>
// clang-format on

#ifdef DEBUG
#define DEBUG_TSPACE_NAMELIST
#endif

#ifdef DISABLE_DEBUG_TSPACE_NAMELIST
#undef DEBUG_TSPACE_NAMELIST
#endif

#ifdef SANITY_CHECK
#define SANITY_CHECK_TSPACE_NAMELIST
#endif

SingleBlock SINGLEBLOCK_Get_Tspace_Description() {
  std::map<std::string, std::string> ListStringValues1_doc;
  std::map<std::string, std::string> ListIntValues1_doc;
  ListStringValues1_doc["TypeTspace"] = "The possible type of T-space\n\
InvGroup: The space of matrices invariant under a group\n   \
RealQuad: The space corresponding to a real quadratic field\n   \
ImagQuad: The space corresponding to a real quadratic field\n   \
Raw     : the space given by matrices\n    \
File    : A file containing the Tspace";
  ListIntValues1_doc["RealImagDim"] = "Default: 0\n\
The dimension d of the space GL_d(R) for R a number ring";
  ListIntValues1_doc["RealImagSum"] = "Default: 0\n\
The sum of the two roots of the polynomial. Only relevant for RealQuad and ImagQuad";
  ListIntValues1_doc["RealImagProd"] = "Default: 0\n\
The product of the two roots of the polynomial. Only relevant for RealQuad and ImagQuad";
  ListStringValues1_doc["SuperMatMethod"] = "Default: NotNeeded\n\
NotNeeded: For InvGroup, RealQuad, ImagQuad, the supermat is computed internally and so this option needs to be selected.\n\
Compute: Compute from the basis of the T-space\n\
File: Use matrix read from the file";
  ListStringValues1_doc["FileInvGroup"] = "Default: unset\n\
The file containing the list of generators";
  ListStringValues1_doc["FileListMat"] = "Default: unset\n\
The file containing the list of matrices";
  ListStringValues1_doc["FileSuperMat"] = "Default: unset\n\
The file containing the SuperMat";
  ListStringValues1_doc["ListComm"] = "Default: trivial\n\
Trivial: This set it up to empty\n\
Use_realimag: Use the commuting from the real or imag case\n\
File: The ListComm will be obtained from the FileListComm";
  ListStringValues1_doc["FileListComm"] = "Default: unset\n\
The file containing the list of commutting matrices";
  ListStringValues1_doc["PtGroupMethod"] = "Default: Trivial\n\
Trivial: Use the group of order 2 generated by -Id_n\n\
Compute: Compute the pointwise group stabilizer by using Plesken Souvignier with the vector configuration obtained by the supermat\n\
InvGroupInit: Set the PtGroup from the group defining it\n\
File: Use the pointwise stabilizer obtained from the file";
  ListStringValues1_doc["FilePtGroupGenerator"] = "Default: unset\n\
unset: If unset then the file is not needed\n\
The filename for the list of generators of the pointwise stabilizer";
  ListStringValues1_doc["FileListSubspaces"] = "Default: unset\n\
unset: If unset then the file is not needed\n\
The filename for the list of subspaces that are preserved";
  ListStringValues1_doc["FileLinSpa"] = "Default: unset\n\
unset: If unset then the file is not needed\n\
The filename used for reading the whole T-space";
  SingleBlock BlockTSPACE;
  BlockTSPACE.setListStringValues_doc(ListStringValues1_doc);
  BlockTSPACE.setListIntValues_doc(ListIntValues1_doc);
  return BlockTSPACE;
}

FullNamelist NAMELIST_GetOneTSPACE() {
  std::map<std::string, SingleBlock> ListBlock;
  ListBlock["TSPACE"] = SINGLEBLOCK_Get_Tspace_Description();
  return FullNamelist(ListBlock);
}

template <typename T>
LinSpaceMatrix<T> ReadLinSpaceFile(std::string const &eFile, std::ostream &os) {
  if (!IsExistingFile(eFile)) {
    std::cerr << "Error in ReadLinSpaceFile\n";
    std::cerr << "eFile=" << eFile << " does not appear to exist\n";
    throw TerminalException{1};
  }
  std::ifstream is(eFile);
  MyMatrix<T> SuperMat = ReadMatrix<T>(is);
  int n = SuperMat.rows();
  std::vector<MyMatrix<T>> ListMat = ReadListMatrix<T>(is);
  std::vector<std::vector<T>> ListLineMat;
  for (auto &eMat : ListMat) {
    std::vector<T> eV = GetLineVector(eMat);
    ListLineMat.push_back(eV);
  }
  std::vector<MyMatrix<T>> ListComm = ReadListMatrix<T>(is);
  std::vector<MyMatrix<T>> ListSubspaces = ReadListMatrix<T>(is);
  std::vector<MyMatrix<T>> PtStabGens = ReadListMatrix<T>(is);
  //
  MyMatrix<T> ListMatAsBigMat = GetListMatAsBigMat(ListMat);
  bool isBravais = IsBravaisSpace(n, ListMat, PtStabGens, os);
  return {n,        isBravais,     SuperMat,
          ListMat,  ListLineMat,   ListMatAsBigMat,
          ListComm, ListSubspaces, PtStabGens};
}

template <typename T>
void WriteLinSpace(std::ostream &os, LinSpaceMatrix<T> const &LinSpa) {
  WriteMatrix(os, LinSpa.SuperMat);
  WriteListMatrix(os, LinSpa.ListMat);
  WriteListMatrix(os, LinSpa.ListComm);
  WriteListMatrix(os, LinSpa.ListSubspaces);
  WriteListMatrix(os, LinSpa.PtStabGens);
}

template <typename T>
void WriteLinSpaceFile(std::string const &eFile,
                       LinSpaceMatrix<T> const &LinSpa) {
  std::ofstream os(eFile);
  WriteLinSpace(os, LinSpa);
}






template <typename T, typename Tint, typename Tgroup>
LinSpaceMatrix<T> ReadTspace(SingleBlock const &Blk, std::ostream &os) {
  std::string const& TypeTspace = Blk.get_string("TypeTspace");
  LinSpaceMatrix<T> LinSpaRet;
  auto set_paperwork = [&]() -> void {
    reset_paperwork(LinSpaRet);
  };
  auto set_listcomm = [&]() -> void {
    std::string const& ListComm = Blk.get_string("ListComm");
    LinSpaRet.ListComm.clear();
#ifdef DEBUG_TSPACE_NAMELIST
    os << "TSPACE: set_listcomm, ListComm=" << ListComm << "\n";
#endif
    if (ListComm == "Trivial") {
      // Nothing to insert in that case.
      return;
    }
    if (ListComm == "Use_realimag") {
      int n = Blk.get_int("RealImagDim");
      int eSum_i = Blk.get_int("RealImagSum");
      int eProd_i = Blk.get_int("RealImagProd");
      T eSum = UniversalScalarConversion<T,int>(eSum_i);
      T eProd = UniversalScalarConversion<T,int>(eProd_i);
      if (TypeTspace == "RealQuad") {
        MyMatrix<T> Imultiplication = GetCommRealQuadratic(n, eSum, eProd);
        LinSpaRet.ListComm.push_back(Imultiplication);
        return;
      }
      if (TypeTspace == "ImagQuad") {
        MyMatrix<T> Imultiplication = GetCommImagQuadratic(n, eSum, eProd);
        LinSpaRet.ListComm.push_back(Imultiplication);
        return;
      }
      std::cerr << "We have TypeTspace=" << TypeTspace << "\n";
      std::cerr << "But only RealQuad and ImagQuad are allowed\n";
      throw TerminalException{1};
    }
    if (ListComm == "File") {
      std::string const& FileListComm = Blk.get_string("FileListComm");
      LinSpaRet.ListComm = ReadListMatrixFile<T>(FileListComm);
      return;
    }
    std::cerr << "TSPACE: Failed to find an option for ListComm that suits\n";
    std::cerr << "TSPACE: ListComm=" << ListComm << "\n";
    std::cerr << "TSPACE: Allowed options: Trivial, Use_realimag, File\n";
    throw TerminalException{1};
  };
  auto set_subspaces = [&]() -> void {
    std::string FileListSubspaces =
      Blk.get_string("FileListSubspaces");
    if (FileListSubspaces != "unset") {
      LinSpaRet.ListSubspaces = ReadListMatrixFile<T>(FileListSubspaces);
    }
  };
  auto set_pt_stab = [&]() -> void {
    std::string PtGroupMethod = Blk.get_string("PtGroupMethod");
#ifdef DEBUG_TSPACE_NAMELIST
    os << "TSPACE: set_pt_stab, PtGroupMethod=" << PtGroupMethod << "\n";
#endif
    if (PtGroupMethod == "Trivial") {
      MyMatrix<T> eGen = -IdentityMat<T>(LinSpaRet.n);
      LinSpaRet.PtStabGens = {eGen};
      return;
    }
    if (PtGroupMethod == "Compute") {
      return reset_pt_stab_gens<T,Tint,Tgroup>(LinSpaRet, os);
    }
    if (PtGroupMethod == "InvGroupInit") {
      std::string const& FileInvGroup = Blk.get_string("FileInvGroup");
      LinSpaRet.PtStabGens = ReadListMatrixFile<T>(FileInvGroup);
      return;
    }
    if (PtGroupMethod == "File") {
      std::string FilePtGroupGenerator =
        Blk.get_string("FilePtGroupGenerator");
      if (FilePtGroupGenerator == "unset") {
        std::cerr << "The FilePtGroupGenerator has not been set up, or set to "
                     "unset\n";
        throw TerminalException{1};
      }
      LinSpaRet.PtStabGens = ReadListMatrixFile<T>(FilePtGroupGenerator);
      return;
    }
    std::cerr << "TSPACE: Failed to find an option for PtGroupMethod that suits\n";
    std::cerr << "TSPACE: PtGroupMethod=" << PtGroupMethod << "\n";
    std::cerr << "TSPACE: Allowed options: Trivial, Compute, InvGroupInit, File\n";
    throw TerminalException{1};
  };
  auto set_is_bravais = [&]() -> void {
#ifdef DEBUG_TSPACE_NAMELIST
    os << "TSPACE: set_is_bravais\n";
#endif
    LinSpaRet.isBravais = IsBravaisSpace(LinSpaRet.n, LinSpaRet.ListMat,
                                         LinSpaRet.PtStabGens, os);
  };
  auto set_supermat = [&]() -> void {
    std::string SuperMatMethod = Blk.get_string("SuperMatMethod");
#ifdef DEBUG_TSPACE_NAMELIST
    os << "TSPACE: set_supermat, SuperMatMethod=" << SuperMatMethod << "\n";
#endif
    if (TypeTspace != "RealQuad" && TypeTspace != "ImagQuad" &&
        TypeTspace != "InvGroup") {
      if (SuperMatMethod == "NotNeeded") {
        std::cerr << "We have TypeTspace=" << TypeTspace << "\n";
        std::cerr << "For NotNeeded, the option needs to be RealQuad, ImagQuad "
                     "or InvGroup\n";
        throw TerminalException{1};
      }
    } else {
      if (SuperMatMethod != "NotNeeded") {
        std::cerr << "For the options RealQuad, ImageQuad and InvGroup, the "
                     "option has to be NotNeeded\n";
        throw TerminalException{1};
      }
    }
    if (TypeTspace == "InvGroup") {
      MyMatrix<T> eMat = IdentityMat<T>(LinSpaRet.n);
      LinSpaRet.SuperMat =
          OrbitBarycenterSymmetricMatrix(eMat, LinSpaRet.ListMat);
      return;
    }
    if (SuperMatMethod == "NotNeeded") {
      return;
    }
    if (SuperMatMethod == "Compute") {
      LinSpaRet.SuperMat =
          GetOnePositiveDefiniteMatrix<T, Tint>(LinSpaRet.ListMat, os);
      return;
    }
    if (SuperMatMethod == "File") {
      std::string FileSuperMat = Blk.get_string("FileSuperMat");
      if (FileSuperMat == "unset") {
        std::cerr << "The FileSuperMat has not been set up, or set to unset\n";
        throw TerminalException{1};
      }
      LinSpaRet.SuperMat = ReadMatrixFile<T>(FileSuperMat);
      return;
    }
    std::cerr << "TSPACE: Failed to find an option for SuperMatMethod that suits\n";
    std::cerr << "TSPACE: SuperMatMethod=" << SuperMatMethod << "\n";
    std::cerr << "TSPACE: Allowed options: NotNeeded, Compute, File\n";
    throw TerminalException{1};
  };
  auto get_linspace = [&]() -> LinSpaceMatrix<T> {
#ifdef DEBUG_TSPACE_NAMELIST
    os << "TSPACE: Beginning of get_linspace TypeTspace=" << TypeTspace << "\n";
#endif
    if (TypeTspace == "RealQuad" || TypeTspace == "ImagQuad") {
      int n = Blk.get_int("RealImagDim");
      int eSum_i = Blk.get_int("RealImagSum");
      int eProd_i = Blk.get_int("RealImagProd");
      T eSum = UniversalScalarConversion<T,int>(eSum_i);
      T eProd = UniversalScalarConversion<T,int>(eProd_i);
#ifdef DEBUG_TSPACE_NAMELIST
      os << "n=" << n << " eSum" << eSum << " eProd=" << eProd << "\n";
#endif
      if (TypeTspace == "RealQuad") {
        LinSpaRet = ComputeRealQuadraticSpace<T>(n, eSum, eProd, os);
      }
      if (TypeTspace == "ImagQuad") {
        LinSpaRet = ComputeImagQuadraticSpace<T>(n, eSum, eProd, os);
      }
      set_listcomm();
      set_subspaces();
      set_pt_stab();
      set_is_bravais();
      return LinSpaRet;
    }
    if (TypeTspace == "InvGroup") {
      std::string FileInvGroup = Blk.get_string("FileInvGroup");
      std::vector<MyMatrix<T>> LGen = ReadListMatrixFile<T>(FileInvGroup);
      if (LGen.size() == 0) {
        std::cerr << "We have 0 matrices\n";
        throw TerminalException{1};
      }
      LinSpaRet.ListMat = BasisInvariantForm(LinSpaRet.n, LGen, os);
      set_paperwork();
      set_supermat();
      set_listcomm();
      set_subspaces();
      set_pt_stab();
      set_is_bravais();
      return LinSpaRet;
    }
    if (TypeTspace == "Raw") {
      std::string const& FileListMat = Blk.get_string("FileListMat");
      LinSpaRet.ListMat = ReadListMatrixFile<T>(FileListMat);
      set_paperwork();
      set_supermat();
      set_listcomm();
      set_subspaces();
      set_pt_stab();
      set_is_bravais();
      return LinSpaRet;
    }
    if (TypeTspace == "File") {
      std::string const& FileLinSpa = Blk.get_string("FileLinSpa");
      return ReadLinSpaceFile<T>(FileLinSpa, os);
    }
    std::cerr << "TSPACE: Failed to find an option for TypeTspace that suits\n";
    std::cerr << "TSPACE: TypeTspace=" << TypeTspace << "\n";
    std::cerr << "TSPACE: Allowed options: Raw, InvGroup, ImagQuad, RealQuad\n";
    throw TerminalException{1};
  };
  LinSpaceMatrix<T> LinSpa = get_linspace();
#ifdef DEBUG_TSPACE_NAMELIST
  os << "TSPACE: ReadTspace: |PtStabGens|=" << LinSpa.PtStabGens.size() << "\n";
  os << "TSPACE: ReadTspace: |ListMat|=" << LinSpa.ListMat.size() << "\n";
#endif
#ifdef SANITY_CHECK_TSPACE_NAMELIST
  for (auto &eGen : LinSpa.PtStabGens) {
    for (auto &eMat : LinSpa.ListMat) {
      MyMatrix<T> eMatImg = eGen * eMat * eGen.transpose();
      if (eMatImg != eMat) {
        std::cerr << "eMat should equal to eMatImg\n";
        throw TerminalException{1};
      }
    }
  }
#endif
  return LinSpa;
}

// clang-format off
#endif  // SRC_LATT_TSPACE_NAMELIST_H_
// clang-format on
